<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Younger的个人站点</title>
  
  <subtitle>不正经码农</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://youngerdev.com/"/>
  <updated>2020-01-08T15:28:23.742Z</updated>
  <id>http://youngerdev.com/</id>
  
  <author>
    <name>Younger</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 多线程</title>
    <link href="http://youngerdev.com/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B.html"/>
    <id>http://youngerdev.com/Android-多线程.html</id>
    <published>2019-12-20T13:06:51.000Z</published>
    <updated>2020-01-08T15:28:23.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android-多线程"><a href="#Android-多线程" class="headerlink" title="Android 多线程"></a>Android 多线程</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Android-多线程&quot;&gt;&lt;a href=&quot;#Android-多线程&quot; class=&quot;headerlink&quot; title=&quot;Android 多线程&quot;&gt;&lt;/a&gt;Android 多线程&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="Android 多线程" scheme="http://youngerdev.com/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android Handler 机制及线程间通信</title>
    <link href="http://youngerdev.com/Android-Handler-%E6%9C%BA%E5%88%B6%E5%8F%8A%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.html"/>
    <id>http://youngerdev.com/Android-Handler-机制及线程间通信.html</id>
    <published>2019-11-28T14:52:44.000Z</published>
    <updated>2020-01-08T15:09:10.358Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要分析 Handler机制和源码，线程切换的原理，下面是大致的目录：</p><ul><li>子线程可以更新UI吗，为什么</li><li>常用的更新子线程更新切换方式</li><li>Handler 源码解析</li><li>handler.post原理</li><li>runOnUiThread原理</li><li>主线程一直死循环取消息，为什么没有卡死</li><li>子线程间怎么发送消息</li></ul><h3 id="在onCreate-中开启子线程更新UI-有问题吗"><a href="#在onCreate-中开启子线程更新UI-有问题吗" class="headerlink" title="在onCreate()中开启子线程更新UI 有问题吗?"></a>在onCreate()中开启子线程更新UI 有问题吗?</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TextView</span> mName;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        mName = (<span class="type">TextView</span>) findViewById(<span class="type">R</span>.id.tv_name);</span><br><span class="line">        mName.setText(<span class="string">"我是在UI线程更新UI"</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Thread</span>(<span class="keyword">new</span> <span class="type">Runnable</span>() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                mName.setText(<span class="string">"我是在非UI线程更新UI"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以看到更新成功了,且没有抛出异常.  子线程能直接更新UI ? 其实是不能。</p><h3 id="为什么不能在子线程更新UI"><a href="#为什么不能在子线程更新UI" class="headerlink" title="为什么不能在子线程更新UI?"></a>为什么不能在子线程更新UI?</h3><p>因为Android的UI控件不是线程安全的,多个线程并发访问可能会导致UI 控件处于不可预期的状态,那既然这样,为什么不加锁呢?<br>缺点: 加锁会让UI访问的逻辑变的复杂,也会降低UI 的访问效率,因为锁的机制会阻塞某些线程的执行. 所有就采用单线程的方式来更新UI</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</span><br><span class="line">                <span class="string">"Only the original thread that created a view hierarchy can touch its views."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上面为什么可以更新UI呢？</p><p>因为执行速度, 因为 ViewRootImpl 这个时候还没创建,这是在调用了 onResume 之后才创建的, ViewRootImpl关于UI 的操作都会 checkThread 如果不在主线程就会抛出异常。所以上面更新的时候还没执行到 checkThread 方法。</p><h3 id="提到异步处理消息，我们常用的子线程更新UI-的方法有哪些呢？"><a href="#提到异步处理消息，我们常用的子线程更新UI-的方法有哪些呢？" class="headerlink" title="提到异步处理消息，我们常用的子线程更新UI 的方法有哪些呢？"></a>提到异步处理消息，我们常用的子线程更新UI 的方法有哪些呢？</h3><ul><li>Handler.sendMessage()</li><li>Handler的post()方法。</li><li>Activity的runOnUiThread()方法。</li><li>View.post(Runnable r)方法。</li></ul><p>作为一个Android 开发，我们肯定会想到 Handler ，下面是一个最简单的但是不太规范的示例，这样我们就可以在子线程中做了处理然后更新 UI 了。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Handler <span class="keyword">handler</span> = <span class="keyword">new</span> Handler()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            Message msg = <span class="keyword">handler</span>.obtainMessage();</span><br><span class="line">            <span class="keyword">handler</span>.sendMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Handler-可以理解为处理器"><a href="#Handler-可以理解为处理器" class="headerlink" title="Handler 可以理解为处理器"></a>Handler 可以理解为处理器</h3><p>首先看下构造方法 我们最常用的 new handler方法做了什么</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用2个参数的构造方法</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Handler</span>(<span class="params">Callback callback, boolean <span class="keyword">async</span></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line"> <span class="comment">// 为了代码整洁，省略了部分内容</span></span><br><span class="line"> 。。。。</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = <span class="keyword">async</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">我们再看下其他不同参数个数的构造方法</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span>(<span class="params">Looper looper, Callback callback, boolean <span class="keyword">async</span></span>)</span> &#123;</span><br><span class="line">        mLooper = looper;</span><br><span class="line">        mQueue = looper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = <span class="keyword">async</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据上面的构造方法可以看出来，  我们在创建Handler 时，如果不指定 callback 时，会默认为空， 如果没有指定 Looper 时，系统会自动 通过  Looper.myLooper()  帮我们指定当前线程的 Looper 。 如果 looper 对象为空，就会抛出异常。</p><p> 我们看下 Looper.myLooper() 是怎么实现的呢</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> static <span class="meta">@Nullable</span> Looper myLooper() &#123;</span><br><span class="line">       <span class="keyword">return</span> sThreadLocal.<span class="keyword">get</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">再看<span class="keyword">get</span>方法怎么实现的</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">get</span>() &#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">           ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings(<span class="meta-string">"unchecked"</span>)</span></span><br><span class="line">               T result = (T)e.value;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> setInitialValue();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 根据方法和资料我们可以知道， ThreadLocal 是所属与线程的，使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。 </p><p>根据经验，有get 肯定有set 的地方，我们看下 Looper 中的 ThreadLocal 的set 的地方</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    prepare(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span>(<span class="params">boolean quitAllowed</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.<span class="keyword">get</span>() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.<span class="keyword">set</span>(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面可以看到， 一个线程中最多只能有一个 Looper ，在想使用到 Looper 的线程 中调用 prepare 方法就可以创建出 Looper了, 在 new handler 时就不会出现 looper 为空的情况了</p><p>但是有没有发现，我们在主线程就是没有调用 prepare 方法呀， 使用的时候也没有报错。这又是怎么回事呢？</p><p>通过看App 启动流程的代码可以发现， 在 ActivityThread 类中的 main 方法 <strong>这个类中的main方法就是整个App 的主线程的执行入口</strong></p><p>在这个方法中，通过调用 Looper.prepareMainLooper() 去初始化了主线程的 looper </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public static void prepareMainLooper() &#123;</span><br><span class="line">    <span class="attribute">prepare(false);</span></span><br><span class="line">    synchronized (Looper.class) &#123;</span><br><span class="line">        if (sMainLooper != null) &#123;</span><br><span class="line">            throw new IllegalStateException("The main Looper has already been prepared.");</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到  prepare(false); 创建了一个不可以退出的 looper。</p><p>然后 main 方法中还通过调用  Looper.loop() 开启主线程的循环。</p><h3 id="Looper-loop-死循环，处理消息"><a href="#Looper-loop-死循环，处理消息" class="headerlink" title="Looper.loop()  死循环，处理消息"></a>Looper.loop()  死循环，处理消息</h3><p>直接看loop方法到底做了什么</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        <span class="comment">//有looper才能循环吧，获取当前线程的 looper</span></span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取当前looper 中的 MessageQueue </span></span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    。。。</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line">。。。</span><br><span class="line">      </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg.<span class="keyword">target</span>.dispatchMessage(msg);</span><br><span class="line">                end = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">。。。</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>中间省略部分源码， 跟着我们上面的分析，因为主线程在 App 初始化时在程序的住入口已经初始化过Looper 和开启了 loop 循环， 内容就是 从当前线程也就是主线程 的looper 关联的 MessageQueue 里不停的死循环 取出 Message 消息， 如果有消息就调用 msg.target.dispatchMessage(msg); 分发消息。 </p><h4 id="msg-target-dispatchMessage-msg"><a href="#msg-target-dispatchMessage-msg" class="headerlink" title="msg.target.dispatchMessage(msg);"></a>msg.target.dispatchMessage(msg);</h4><p>处理消息。消息分发 但是这个 msg.target 又是什么东西呢  </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">经过看源码 msg.<span class="keyword">target</span> 的赋值是在这做的 Message 类中</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Message obtain(Handler h, <span class="keyword">int</span> what,</span><br><span class="line">            <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, Object obj) &#123;</span><br><span class="line">        Message m = obtain();</span><br><span class="line">        m.<span class="keyword">target</span> = h;</span><br><span class="line">        m.what = what;</span><br><span class="line">        m.arg1 = arg1;</span><br><span class="line">        m.arg2 = arg2;</span><br><span class="line">        m.obj = obj;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Message m = sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = <span class="keyword">null</span>;</span><br><span class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">                sPoolSize--;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>msg.target其实就是初始化的handler，然后调用Handler的dispatchMessage();</p><p>从消息池中取出消息，如果没有的话就直接new一个Message对象，所以我们在写项目创建Message对象的时候尽量用handle.obtainMessage()，不要直接new Message()，复用会比较好。</p><p>知道 msg.target 就是 handler 了，那看下 handler 的 dispatchMessage 方法</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">          handleCallback(msg);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          handleMessage(msg);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">先判断msg.的callback是否为空，接着再判断<span class="keyword">handler</span>的mCallBack是否为空，</span><br><span class="line">如果都为空，所以执行handleMessage()，这里面是一个空方法，需要我们重写。</span><br><span class="line">上面那个 msg.callback 和  mCallback 怎么用呢？请接着往下看</span><br></pre></td></tr></table></figure><h3 id="handler-post-方法"><a href="#handler-post-方法" class="headerlink" title="handler.post 方法"></a>handler.post 方法</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">     <span class="keyword">handler</span>.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> post(Runnable r)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function">Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    最后把 Runnable 的callback 赋值成 Message 的 callback  </span><br><span class="line">    再结合上面的 dispatchMessage 方法  ， msg.callback 就不是空了 </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">调用 callback 的 run 方法。 <span class="keyword">handler</span> 的 post 方法就这这么简单，</span><br><span class="line">把一个可以可以执行的 runnable 放到 msg 的 callback 中抛到主线程，</span><br><span class="line">调用 run 方法执行，然后这个 run 方法中的内容就是在主线程执行的了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接下来看 创建Handler 的另一种方式，可以有个 callback 的写法， 这个时候</span><br><span class="line"><span class="keyword">handler</span> 中的 mCallback 就不为空了， 就可以执行了，直接执行 callback 中的方法即可</span><br><span class="line">这个也是在当前线程（主线程）执行的。</span><br><span class="line">    Handler <span class="keyword">handler</span> = <span class="keyword">new</span> Handler(<span class="keyword">new</span> Handler.Callback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><p>MessageQueue的 next 方法做了什么操作呢</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="selector-tag">Message</span> <span class="selector-tag">next</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="selector-tag">for</span> (;;) &#123;</span><br><span class="line">            <span class="selector-tag">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="selector-tag">Binder</span><span class="selector-class">.flushPendingCommands</span>();</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//请注意这个方法 这个</span></span><br><span class="line">            <span class="selector-tag">nativePollOnce</span>(ptr, nextPollTimeoutMillis);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是死循环取消息 同一线程在同一时间只能处理一个消息，同一线程代码执行是不具有并发性，所以需要队列来保存消息和安排每个消息的处理顺序。</p><p>多个其他线程往UI线程发送消息，UI线程必须把这些消息保持到一个列表（它同一时间不能处理那么多任务),然后挨个拿出来处理，每一个Looper线程都会维护这样一个队列，而且仅此一个，这个队列的消息只能由该线程处理。 </p><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>Message 就没有太多可以说的，它就是一个消息的载体，用来保存消息的。</p><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p>常用的方法 </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> sendMessage(Message msg)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">sendMessageDelayed</span><span class="params">(msg, <span class="number">0</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> sendEmptyMessage(<span class="keyword">int</span> what)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(what, <span class="number">0</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最后都会调用到 </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        msg.<span class="keyword">target</span> = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> queue.<span class="title">enqueueMessage</span><span class="params">(msg, uptimeMillis)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    接着看 queue.enqueueMessage 是怎么处理的呢</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.<span class="keyword">target</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        msg.<span class="keyword">target</span> + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">                Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                msg.recycle();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            <span class="keyword">boolean</span> needWake;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">                <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               needWake = mBlocked &amp;&amp; p.<span class="keyword">target</span> == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">            <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">主要目的就是把 Message 添加到 MessageQueue 中 </span><br><span class="line">如果消息在此时queue 中没有消息，就加入队列后 nativeWake  唤醒，通知取消息，</span><br><span class="line">如果队列中有消息，就加入进去。</span><br></pre></td></tr></table></figure><h3 id="主线程一直-loop-死循环为什么没有卡死"><a href="#主线程一直-loop-死循环为什么没有卡死" class="headerlink" title="主线程一直 loop 死循环为什么没有卡死"></a>主线程一直 loop 死循环为什么没有卡死</h3><p>主线程的死循环一直运行是不是特别消耗 CPU 资源呢？ 其实不然，这里就涉及到 Linux pipe/epoll机制，简单说就是在主线程的 MessageQueue 没有消息时，便阻塞在 loop 的 queue.next() 中的 nativePollOnce() 方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作。</p><p>这里采用的 epoll 机制，是一种 IO 多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步 I/O ，即读写是阻塞的。 所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量 CPU 资源。</p><p><strong>其实这也是整个 Android 系统的做法，App 启动，然后就进入死循环，如果没有消息，就阻塞在哪些，AMS， WMS 等等 会通过binder抛过来一些消息，然后执行 onCreate 之类的方法，Activity 的生命周期的方法都是 msg，有消息过来就执行</strong></p><h3 id="runOnUiThread"><a href="#runOnUiThread" class="headerlink" title="runOnUiThread"></a>runOnUiThread</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">        mHandler.post(action);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        action.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到代码 如果当前线程是主线程， 直接调用 Runnable 的run 方法，去执行， 如果不是主线程， 则调用 mHandler 的 post 方法 ，上面我们已经分析过 post 方法的原理了。 上面这个 mHandler 就是 Activity 的 Handler 也就是主线程的 Handler ，发送到主线程执行这个 Runnable。</p><h3 id="子线程间怎么发送消息"><a href="#子线程间怎么发送消息" class="headerlink" title="子线程间怎么发送消息"></a>子线程间怎么发送消息</h3><p>根据上面的分析，我们在子线程中要使用handler 发送消息的话， 需要 手动在子线程的Handler 创建之前，调用 Looper.prepare 创建一个looper 来跟当前线程关联， 然后在创建完成 handler之后 调用 Looper.loop() 开启消息循环， 然后其他线程就可以通过这个线程创建出的 handler 往这个线程发送消息了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Handler 机制是现在各个公司面试必问的问题，掌握 Handler 原理对我们日常开发工作也是非常有帮助的。代码量也不大，比较好懂，作为一个 Android 开发工程师非常有必要掌握这些知识点。 欢迎交流学习。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/guolin_blog/article/details/9991569" target="_blank" rel="noopener">Android异步消息处理机制完全解析</a></p><p><a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/os/Handler.java?q=Handler" target="_blank" rel="noopener">Android 源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要分析 Handler机制和源码，线程切换的原理，下面是大致的目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子线程可以更新UI吗，为什么&lt;/li&gt;
&lt;li&gt;常用的更新子线程更新切换方式&lt;/li&gt;
&lt;li&gt;Handler 源码解析&lt;/li&gt;
&lt;li&gt;handler.post原理&lt;/
      
    
    </summary>
    
    
      <category term="Android 多线程" scheme="http://youngerdev.com/tags/Android-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Handler机制" scheme="http://youngerdev.com/tags/Handler%E6%9C%BA%E5%88%B6/"/>
    
      <category term="Handler源码" scheme="http://youngerdev.com/tags/Handler%E6%BA%90%E7%A0%81/"/>
    
      <category term="子线程更新UI" scheme="http://youngerdev.com/tags/%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%9B%B4%E6%96%B0UI/"/>
    
      <category term="runOnUiThread" scheme="http://youngerdev.com/tags/runOnUiThread/"/>
    
      <category term="线程间通信" scheme="http://youngerdev.com/tags/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>OkHttpUtils 源码解析</title>
    <link href="http://youngerdev.com/OkHttpUtils-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html"/>
    <id>http://youngerdev.com/OkHttpUtils-源码解析.html</id>
    <published>2019-10-20T05:51:35.000Z</published>
    <updated>2019-10-20T06:43:13.507Z</updated>
    
    <content type="html"><![CDATA[<p>接上篇的 <a href="https://youngerdev.com/OkHttp-源码解析.html">OkHttp 源码解析</a>，目前项目中更多的用到的是 <a href="https://github.com/hongyangAndroid/okhttputils" target="_blank" rel="noopener">OkHttpUtils</a> 和 <a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp</a>  所以有必要了解它的原理，以便遇到网络相关的问题时，可以及时的定位并解决问题，关于 OkHttp 源码相关的内容请看上篇， 请在阅读过上篇的基础上来看这篇会更好的理解，下面就开始吧。</p><p><a href="https://github.com/hongyangAndroid/okhttputils" target="_blank" rel="noopener">OkHttpUtils 项目</a></p><p>本文的目录大致是这样：</p><ul><li>OkHttpUtils 简单使用</li><li>OkHttpUtils 源码解析（V2.6.2）</li><li>OkHttp 和OkHttp 的对比</li></ul><h3 id="OkHttpUtils-简单使用"><a href="#OkHttpUtils-简单使用" class="headerlink" title="OkHttpUtils 简单使用"></a>OkHttpUtils 简单使用</h3><p>首先要在 gradle 中加上</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'com.zhy:okhttputils:2.6.2'</span></span><br></pre></td></tr></table></figure><p>将直接使用okhttp默认的配置生成OkhttpClient，如果你有任何配置，记得在Application中调用initClient方法进行设置。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    public void onCreate()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">        <span class="type">OkHttpClient</span> okHttpClient = <span class="keyword">new</span> <span class="type">OkHttpClient</span>.<span class="type">Builder</span>()</span><br><span class="line"><span class="comment">//                .addInterceptor(new LoggerInterceptor("TAG"))</span></span><br><span class="line">                  .connectTimeout(<span class="number">10000</span>L, <span class="type">TimeUnit</span>.<span class="type">MILLISECONDS</span>)</span><br><span class="line">                  .readTimeout(<span class="number">10000</span>L, <span class="type">TimeUnit</span>.<span class="type">MILLISECONDS</span>)</span><br><span class="line">                  <span class="comment">//其他配置</span></span><br><span class="line">                 .build();</span><br><span class="line">                 </span><br><span class="line">        <span class="type">OkHttpUtils</span>.initClient(okHttpClient);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在具体的使用过程中</p><p>GET 请求</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> url = <span class="string">"http://www.csdn.net/"</span>;</span><br><span class="line">OkHttpUtils</span><br><span class="line">    .<span class="keyword">get</span>()</span><br><span class="line">    .url(url)</span><br><span class="line">    .addParams(<span class="string">"username"</span>, <span class="string">"hyman"</span>)</span><br><span class="line">    .addParams(<span class="string">"password"</span>, <span class="string">"123"</span>)</span><br><span class="line">    .build()</span><br><span class="line">    .<span class="keyword">execute</span>(<span class="keyword">new</span> StringCallback()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> void onError(<span class="built_in">Request</span> <span class="built_in">request</span>, Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> void onResponse(<span class="built_in">String</span> <span class="built_in">response</span>)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>Post JSON</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OkHttpUtils</span><br><span class="line">  .postString()</span><br><span class="line">  .url(url)</span><br><span class="line">  .content(<span class="keyword">new</span> <span class="type">Gson</span>().toJson(<span class="keyword">new</span> <span class="type">User</span>(<span class="string">"zhy"</span>, <span class="string">"123"</span>)))</span><br><span class="line">   .mediaType(MediaType.parse(<span class="string">"application/json; charset=utf-8"</span>))</span><br><span class="line">  .build()</span><br><span class="line">  .execute(<span class="keyword">new</span> <span class="type">MyStringCallback</span>());</span><br></pre></td></tr></table></figure><p>能看出常用的GET ，POST 请求写起来非常简单流畅， 并且网络回调直接到主线程中了，可以直接处理数据。</p><h3 id="OkHttpUtils-源码解析"><a href="#OkHttpUtils-源码解析" class="headerlink" title="OkHttpUtils 源码解析"></a>OkHttpUtils 源码解析</h3><p>我们通过这个get 请求，进去到源码中看下是如何封装的。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">OkHttpUtils</span><span class="selector-class">.get</span>()<span class="selector-class">.url</span>(<span class="string">"http://www.baidu.com"</span>)<span class="selector-class">.build</span>()<span class="selector-class">.execute</span>(new com.zhy.http.okhttp.callback.Callback() &#123;</span><br><span class="line">           <span class="variable">@Override</span></span><br><span class="line">           public Object parseNetworkResponse(Response response, int id) throws Exception &#123;</span><br><span class="line">               <span class="selector-tag">return</span> <span class="selector-tag">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           @<span class="selector-tag">Override</span></span><br><span class="line">           <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">onError</span>(Call call, Exception e, int id) &#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="variable">@Override</span></span><br><span class="line">           public void onResponse(Object response, int id) &#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="OkHttpUtils"><a href="#OkHttpUtils" class="headerlink" title="OkHttpUtils"></a>OkHttpUtils</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_MILLISECONDS = <span class="number">10</span>_000L;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> OkHttpUtils mInstance;</span><br><span class="line">    <span class="keyword">private</span> OkHttpClient mOkHttpClient;</span><br><span class="line">    <span class="keyword">private</span> Platform mPlatform;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> OkHttpUtils(OkHttpClient okHttpClient)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (okHttpClient == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mOkHttpClient = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mOkHttpClient = okHttpClient;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mPlatform = Platform.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OkHttpUtils initClient(OkHttpClient okHttpClient)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (OkHttpUtils.class)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    mInstance = <span class="keyword">new</span> OkHttpUtils(okHttpClient);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OkHttpUtils getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">initClient</span><span class="params">(<span class="keyword">null</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Executor getDelivery()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> mPlatform.<span class="title">defaultCallbackExecutor</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> OkHttpClient getOkHttpClient()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> mOkHttpClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GetBuilder get()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GetBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PostStringBuilder postString()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PostStringBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PostFileBuilder postFile()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PostFileBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PostFormBuilder post()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PostFormBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OtherRequestBuilder put()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OtherRequestBuilder(METHOD.PUT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HeadBuilder head()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeadBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OtherRequestBuilder delete()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OtherRequestBuilder(METHOD.DELETE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OtherRequestBuilder patch()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OtherRequestBuilder(METHOD.PATCH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>根据代码 能看出 OkHttpUtils 做了双重锁定的单例处理，因为一个App有一个 OkHttpClient 对象就行了。new 出了一个 OkHttpClient 。 </p><p>我们在Application中初始化后，就生成这样一个对象， 以后每次用的时候就取得这个，无需重复创建。</p><p>实例化 OkHttpUtils 时 会创建 mPlatform = Platform.get() 。我们看下这是什么。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Platform PLATFORM = findPlatform();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Platform get()</span><br><span class="line">&#123;</span><br><span class="line">    L.e(PLATFORM.getClass().toString());</span><br><span class="line">    <span class="keyword">return</span> PLATFORM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Platform findPlatform()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Class.forName(<span class="string">"android.os.Build"</span>);</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Android();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Platform();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Executor defaultCallbackExecutor()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Handler <span class="keyword">handler</span> = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> execute(Runnable r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">handler</span>.post(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外在OkHttpUtils的构造方法中可以注意到有一个mPlatform的变量，他会根据当前是Android还是其他平台的不同被初始化为Android主线程或者普通线程池。</p><p>当是 Android 系统，new 了一个Android ，里面一个内部类，实现了 Executor， 创建了一个 handler 传入 Looper.getMainLooper() 主线程的 Looper，线程池执行时在这把可执行的 runnable 发送到主线程， 然后执行，就实现了线程切换。</p><p>它的功能就是实现线程之间的切换的。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GetRequest</span></span><br><span class="line">  @Override</span><br><span class="line">    public RequestCall build()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (params != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">url</span> = appendParams(<span class="built_in">url</span>, params);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GetRequest(<span class="built_in">url</span>, tag, params, headers,id).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//postString</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> PostStringBuilder();</span><br><span class="line"></span><br><span class="line">public class PostStringBuilder extends OkHttpRequestBuilder&lt;PostStringBuilder&gt;</span><br><span class="line">&#123;</span><br><span class="line">    private <span class="built_in">String</span> content;</span><br><span class="line">    private MediaType mediaType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public PostStringBuilder content(<span class="built_in">String</span> content)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PostStringBuilder mediaType(MediaType mediaType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.mediaType = mediaType;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public RequestCall build()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PostStringRequest(<span class="built_in">url</span>, tag, params, headers, content, mediaType,id).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当我们调用build 方法时做了什么操作呢 </span><br><span class="line">    public PostStringRequest(<span class="built_in">String</span> <span class="built_in">url</span>, <span class="built_in">Object</span> tag, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; params, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; headers, <span class="built_in">String</span> content, MediaType mediaType,<span class="built_in">int</span> id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="built_in">url</span>, tag, params, headers,id);</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">        <span class="keyword">this</span>.mediaType = mediaType;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.content == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Exceptions.illegalArgument(<span class="string">"the content can not be null !"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mediaType == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.mediaType = MEDIA_TYPE_PLAIN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">把我们设置的参数传递过来， 比如我们经常用的 mediaType 和 content 组装起来， </span><br><span class="line">在执行网络请求的时候会把这些参数按照需要配置好，传入。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//OkHttpRequest</span></span><br><span class="line"></span><br><span class="line">    protected Request.Builder builder = <span class="keyword">new</span> Request.Builder();</span><br><span class="line"></span><br><span class="line">    protected OkHttpRequest(<span class="built_in">String</span> <span class="built_in">url</span>, <span class="built_in">Object</span> tag,</span><br><span class="line">                            <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; params, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; headers,<span class="built_in">int</span> id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.url = <span class="built_in">url</span>;</span><br><span class="line">        <span class="keyword">this</span>.tag = tag;</span><br><span class="line">        <span class="keyword">this</span>.params = params;</span><br><span class="line">        <span class="keyword">this</span>.headers = headers;</span><br><span class="line">        <span class="keyword">this</span>.id = id ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">url</span> == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Exceptions.illegalArgument(<span class="string">"url can not be null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        initBuilder();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用 get请求 new GetBuilder() 创建了一个继承 OkHttpRequest 的 GetRequest，配置需要的参数。</p><h4 id="执行网络请求-execute"><a href="#执行网络请求-execute" class="headerlink" title="执行网络请求 execute"></a>执行网络请求 execute</h4><p>然后 看下 execute 的具体内容</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> execute(Callback callback)</span><br><span class="line">    &#123;</span><br><span class="line">        buildCall(callback);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            callback.onBefore(request, getOkHttpRequest().getId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OkHttpUtils.getInstance().execute(<span class="keyword">this</span>, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接着看 execute 的内容</span><br><span class="line">可以看其最后只是将RequestCall和callback传递给了OkHttpUtils类的execute方法，</span><br><span class="line">也就是说，最终还是调用了okhttp3.<span class="keyword">Call</span>的enqueue()方法，在这里执行了真正的网络请求：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> execute(<span class="keyword">final</span> RequestCall requestCall, Callback callback)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback == <span class="keyword">null</span>)</span><br><span class="line">            callback = Callback.CALLBACK_DEFAULT;</span><br><span class="line">          <span class="comment">//如果没有写回调，给了一个默认的</span></span><br><span class="line">        <span class="keyword">final</span> Callback finalCallback = callback;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> id = requestCall.getOkHttpRequest().getId();</span><br><span class="line"></span><br><span class="line"><span class="comment">//requestCall.getCall() 调用了 enqueue进行网络请求，你肯定能猜出来 requestCall.getCall()的内容， </span></span><br><span class="line"><span class="comment">//看下面吧， 我贴出来了，就是 返回了一个OkHttpClient创建的call。</span></span><br><span class="line">        requestCall.getCall().enqueue(<span class="keyword">new</span> okhttp3.Callback()</span><br><span class="line">        &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> onFailure(<span class="keyword">Call</span> <span class="keyword">call</span>, <span class="keyword">final</span> IOException e)</span><br><span class="line">            &#123;</span><br><span class="line">                sendFailResultCallback(<span class="keyword">call</span>, e, finalCallback, id);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> onResponse(<span class="keyword">final</span> <span class="keyword">Call</span> <span class="keyword">call</span>, <span class="keyword">final</span> Response response)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                <span class="comment">//如果请求被取消 就结束</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">call</span>.isCanceled())</span><br><span class="line">                    &#123;</span><br><span class="line">                        sendFailResultCallback(<span class="keyword">call</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled!"</span>), finalCallback, id);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以看到方法中 code码是 【200，300）的算是成功，其他的是失败</span></span><br><span class="line">                    <span class="keyword">if</span> (!finalCallback.validateReponse(response, id))</span><br><span class="line">                    &#123;</span><br><span class="line">                        sendFailResultCallback(<span class="keyword">call</span>, <span class="keyword">new</span> IOException(<span class="string">"request failed , reponse's code is : "</span> + response.code()), finalCallback, id);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Object o = finalCallback.parseNetworkResponse(response, id);</span><br><span class="line">                    sendSuccessResultCallback(o, finalCallback, id);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                    sendFailResultCallback(<span class="keyword">call</span>, e, finalCallback, id);</span><br><span class="line">                &#125; <span class="keyword">finally</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (response.body() != <span class="keyword">null</span>)</span><br><span class="line">                        response.body().close();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">public</span> Call buildCall(Callback callback)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">request</span> = generateRequest(callback);</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (readTimeOut &gt; <span class="number">0</span> || writeTimeOut &gt; <span class="number">0</span> || connTimeOut &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">readTimeOut</span> = readTimeOut &gt; <span class="number">0</span> ? readTimeOut : OkHttpUtils.DEFAULT_MILLISECONDS;</span><br><span class="line">        <span class="attribute">writeTimeOut</span> = writeTimeOut &gt; <span class="number">0</span> ? writeTimeOut : OkHttpUtils.DEFAULT_MILLISECONDS;</span><br><span class="line">        <span class="attribute">connTimeOut</span> = connTimeOut &gt; <span class="number">0</span> ? connTimeOut : OkHttpUtils.DEFAULT_MILLISECONDS;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">clone</span> = OkHttpUtils.getInstance().getOkHttpClient().newBuilder()</span><br><span class="line">                .readTimeout(readTimeOut, TimeUnit.MILLISECONDS)</span><br><span class="line">                .writeTimeout(writeTimeOut, TimeUnit.MILLISECONDS)</span><br><span class="line">                .connectTimeout(connTimeOut, TimeUnit.MILLISECONDS)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="attribute">call</span> = clone.newCall(request);</span><br><span class="line">    &#125; else</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">call</span> = OkHttpUtils.getInstance().getOkHttpClient().newCall(request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看看处理返回成功的回调方法</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> sendSuccessResultCallback(<span class="keyword">final</span> Object object, <span class="keyword">final</span> Callback callback, <span class="keyword">final</span> <span class="keyword">int</span> id)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (callback == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    mPlatform.execute(<span class="keyword">new</span> Runnable()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> run()</span><br><span class="line">        &#123;</span><br><span class="line">            callback.onResponse(object, id);</span><br><span class="line">            callback.onAfter(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是有点眼熟 mPlatform 其实就是上面的那个 Android ， 把这个 runnable 发送到主线程。</p><p>在本文中，okhttputils将初始化OkHttpClient的动作提取出来，这样同一个应用只需要在最开始的时候配置一下诸如网络超时、cookie等既可。</p><p>在具体的实现中，通过OkHttpRequestBuilder收集网络请求的属性并传递给OkHttpRequest，在其子类中按照不同的需要实现生成Request的方法。</p><p>OkHttpRequestBuilder的build()方法会生成RequestCall对象，RequestCall对象的execute()方法会调用OkHttpRequestBuilder对象的generateRequest()方法产生Request，并据此产生Call对象，最后通过该Call对象的enqueue方法执行网络请求。</p><p>至此 OkHttpUtils 的源码分析完成了，其实代码相对简单，就是对 OkHttp 的一个封装， 少写了一些代码， 把常用的 get ， post ，postString，postFile，head，put， delete 都进行了一个封装，调用起来非常方便。</p><p>并且网络请求的返回内容也回调到主线程，方便进行 UI 操作，</p><p>这也解决了上一个篇文章中说的 OkHttp 的两个缺点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接上篇的 &lt;a href=&quot;https://youngerdev.com/OkHttp-源码解析.html&quot;&gt;OkHttp 源码解析&lt;/a&gt;，目前项目中更多的用到的是 &lt;a href=&quot;https://github.com/hongyangAndroid/okhttputi
      
    
    </summary>
    
    
      <category term="源码" scheme="http://youngerdev.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="OkHttp源码" scheme="http://youngerdev.com/tags/OkHttp%E6%BA%90%E7%A0%81/"/>
    
      <category term="OkHttpUtils源码" scheme="http://youngerdev.com/tags/OkHttpUtils%E6%BA%90%E7%A0%81/"/>
    
      <category term="源码解析" scheme="http://youngerdev.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android 源码" scheme="http://youngerdev.com/tags/Android-%E6%BA%90%E7%A0%81/"/>
    
      <category term="网络请求" scheme="http://youngerdev.com/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
      <category term="Android网络" scheme="http://youngerdev.com/tags/Android%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp 源码解析</title>
    <link href="http://youngerdev.com/OkHttp-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html"/>
    <id>http://youngerdev.com/OkHttp-源码解析.html</id>
    <published>2019-10-19T05:49:09.000Z</published>
    <updated>2019-10-20T12:15:08.908Z</updated>
    
    <content type="html"><![CDATA[<p>接上篇的 <a href="https://youngerdev.com/Volley-源码解析.html">Volley 源码</a>解析，目前项目中更多的用到的是 <a href="https://github.com/hongyangAndroid/okhttputils" target="_blank" rel="noopener">OkHttpUtils</a> 和 <a href="https://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp</a> 所以有必要了解它的原理，以便遇到网络相关的问题时，可以及时的定位并解决问题，下面就开始吧。</p><p>本文的目录大致是这样：</p><ul><li>OkHttp 的基本使用</li><li>OkHttp 的源码解析（V3.5.0）</li><li>OkHttp 连接池复用</li><li>OkHttp 的优缺点</li></ul><h3 id="OkHttp-的基本使用"><a href="#OkHttp-的基本使用" class="headerlink" title="OkHttp 的基本使用"></a>OkHttp 的基本使用</h3><p>在 gradle 中添加依赖</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'com.squareup.okhttp3:okhttp:3.5.0'</span></span><br></pre></td></tr></table></figure><p>1.首先创建OkHttpClient</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient<span class="built_in"> client </span>= new OkHttpClient();</span><br></pre></td></tr></table></figure><p>2.构造Request对象</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Request</span> <span class="built_in">request</span> = <span class="keyword">new</span> <span class="built_in">Request</span>.Builder()</span><br><span class="line">                .<span class="keyword">get</span>()</span><br><span class="line">                .url(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure><p>3.将Request封装为Call</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Call</span> <span class="keyword">call</span> = client.newCall(request);</span><br></pre></td></tr></table></figure><p>4.根据需要调用同步或者异步请求方法 </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步调用,返回Response,会抛出IO异常</span></span><br><span class="line">Response response = <span class="keyword">call</span>.execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步调用,并设置回调函数</span></span><br><span class="line"><span class="keyword">call</span>.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> onFailure(<span class="keyword">Call</span> <span class="keyword">call</span>, IOException e) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> onResponse(<span class="keyword">Call</span> <span class="keyword">call</span>, Response response) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                Log.e(<span class="string">"=====Younger=="</span>, <span class="string">"==="</span> + (Looper.myLooper() == Looper.getMainLooper()));</span><br><span class="line">                <span class="comment">//打印出的结果是false ， 可以看出 这个回调并没有回到主线程，需要我们自己处理线程切换的问题</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>同步调用会阻塞主线程，一般不用</p><p>异步调用的回调函数是在子线程,我们不能在子线程更新UI,需要借助于runOnUiThread()方法或者Handler来处理</p><p>post 也是类似的， 相信大家都会用使用，接下来我们来看重头戏-源码。</p><h3 id="OkHttp-源码解析"><a href="#OkHttp-源码解析" class="headerlink" title="OkHttp 源码解析"></a>OkHttp 源码解析</h3><p><img src="/images/okhttp_interceptors.png" alt></p><h4 id="okHttpClient"><a href="#okHttpClient" class="headerlink" title="okHttpClient"></a>okHttpClient</h4><p>首先来看，我们进行网络请求时使用的方法</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Call call = okHttpClient.<span class="keyword">new</span><span class="type">Call</span>(request);</span><br><span class="line"></span><br><span class="line">实际调用</span><br><span class="line"></span><br><span class="line">@Override <span class="keyword">public</span> Call <span class="keyword">new</span><span class="type">Call</span>(Request request) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">RealCall</span>(<span class="built_in">this</span>, request, <span class="literal">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="type"></span>了一个 RealCall，这是它的构造方法</span><br><span class="line"></span><br><span class="line">  RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123;</span><br><span class="line">    <span class="built_in">this</span>.client = client;</span><br><span class="line">    <span class="built_in">this</span>.originalRequest = originalRequest;</span><br><span class="line">    <span class="built_in">this</span>.forWebSocket = forWebSocket;</span><br><span class="line">    <span class="built_in">this</span>.retryAndFollowUpInterceptor = <span class="keyword">new</span> <span class="type">RetryAndFollowUpInterceptor</span>(client, forWebSocket);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="RealCall"><a href="#RealCall" class="headerlink" title="RealCall"></a>RealCall</h4><p>实际上的 Call 的 enqueue 调用的是 RealCall的 enqueue方法</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span>.enqueue(<span class="keyword">new</span> ...);</span><br></pre></td></tr></table></figure><p>下面我们看下 RealCall的 enqueue是如何实现的</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">    executed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  captureCallStackTrace();</span><br><span class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最终的请求处理是 dispatcher 来完成的，接下来看下 dispatcher</p><h4 id="dispatcher"><a href="#dispatcher" class="headerlink" title="dispatcher"></a>dispatcher</h4><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//最大并发请求书</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> maxRequests = <span class="number">64</span>;</span><br><span class="line"> <span class="comment">//每个主机的最大请求数</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> maxRequestsPerHost = <span class="number">5</span>;</span><br><span class="line"> <span class="keyword">private</span> Runnable idleCallback;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** 执行的线程池. Created lazily. */</span></span><br><span class="line"> <span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将要运行的异步请求队列</span></span><br><span class="line"> <span class="comment">/** Ready async calls in the order they'll be run. */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//正在执行的异步请求队列</span></span><br><span class="line"> <span class="comment">/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"><span class="comment">//正在执行的同步请求队列</span></span><br><span class="line"> <span class="comment">/** Running synchronous calls. Includes canceled calls that haven't finished yet. */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Dispatcher(ExecutorService executorService) &#123;</span><br><span class="line">   <span class="keyword">this</span>.executorService = executorService;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Dispatcher() &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService executorService() &#123;</span><br><span class="line">   <span class="keyword">if</span> (executorService == <span class="literal">null</span>) &#123;</span><br><span class="line">     executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">         <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="literal">false</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> executorService;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Dispatcher 有两个构造方法，可以自己指定线程池， 如果没有指定， 则会默认创建默认线程池，可以看到核心数为0，缓存数可以是很大， 比较适合执行大量的耗时比较少的任务。</p><p>接着看 enqueue是如何实现的</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> enqueue(AsyncCall <span class="keyword">call</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (runningAsyncCalls.<span class="keyword">size</span>() &lt; maxRequests &amp;&amp; runningCallsForHost(<span class="keyword">call</span>) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">    runningAsyncCalls.add(<span class="keyword">call</span>);</span><br><span class="line">    executorService().execute(<span class="keyword">call</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    readyAsyncCalls.add(<span class="keyword">call</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当正在运行的异步请求队列中的数量小于64， 并且 正在运行的请求主机数小于5，把请求加载到runningAsyncCalls 中并在线程池中执行， 否则就加入到 readyAsyncCalls 进行缓存等待。</p><p>runningCallsForHost是如何实现的呢</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/** Returns <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> <span class="built_in">running</span> calls <span class="keyword">that</span> share a host <span class="keyword">with</span> &#123;@code call&#125;. */</span><br><span class="line">private int runningCallsForHost(AsyncCall call) &#123;</span><br><span class="line">  int <span class="literal">result</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (AsyncCall c : runningAsyncCalls) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c.host().<span class="keyword">equals</span>(call.host())) <span class="literal">result</span>++;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">  return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正在执行的网络请求中 同一个host最多只能是5个。</p><p>上面可以看到传递进来的是 AsyncCall 然后 execute 那我们看下 AsyncCall方法</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Callback</span> responseCallback;</span><br><span class="line"></span><br><span class="line">    <span class="type">AsyncCall</span>(<span class="type">Callback</span> responseCallback) &#123;</span><br><span class="line">      <span class="keyword">super</span>(<span class="string">"OkHttp %s"</span>, redactedUrl());</span><br><span class="line">      <span class="keyword">this</span>.responseCallback = responseCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> host() &#123;</span><br><span class="line">      <span class="keyword">return</span> originalRequest.url().host();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Request</span> request() &#123;</span><br><span class="line">      <span class="keyword">return</span> originalRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">RealCall</span> get() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">RealCall</span>.<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">protected</span> void execute() &#123;</span><br><span class="line">      boolean signalledCallback = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//获取请求报文</span></span><br><span class="line">        <span class="type">Response</span> response = getResponseWithInterceptorChain();</span><br><span class="line">        <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">          signalledCallback = <span class="literal">true</span>;</span><br><span class="line">          responseCallback.onFailure(<span class="type">RealCall</span>.<span class="keyword">this</span>, <span class="keyword">new</span> <span class="type">IOException</span>(<span class="string">"Canceled"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          signalledCallback = <span class="literal">true</span>;</span><br><span class="line">          responseCallback.onResponse(<span class="type">RealCall</span>.<span class="keyword">this</span>, response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (<span class="type">IOException</span> e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">          <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">          <span class="type">Platform</span>.get().log(<span class="type">INFO</span>, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          responseCallback.onFailure(<span class="type">RealCall</span>.<span class="keyword">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看到 NamedRunnable 实现了 Runnable，AsyncCall 中的 execute 是对网络请求的具体处理。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Response response</span> = getResponseWithInterceptorChain();</span><br></pre></td></tr></table></figure><p>能明显看出这就是对请求的处理，在看它的具体实现之前先看下 client.dispatcher().finished 的方法实现。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/** Used by &#123;@code AsyncCall#run&#125; to signal completion. */</span></span><br><span class="line">  <span class="keyword">void</span> finished(AsyncCall <span class="keyword">call</span>) &#123;</span><br><span class="line">    finished(runningAsyncCalls, <span class="keyword">call</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Used by &#123;@code Call#execute&#125; to signal completion. */</span></span><br><span class="line">  <span class="keyword">void</span> finished(RealCall <span class="keyword">call</span>) &#123;</span><br><span class="line">    finished(runningSyncCalls, <span class="keyword">call</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后调用这个</span></span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> finished(Deque&lt;T&gt; calls, T <span class="keyword">call</span>, <span class="keyword">boolean</span> promoteCalls) &#123;</span><br><span class="line">    <span class="keyword">int</span> runningCallsCount;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!calls.remove(<span class="keyword">call</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">      <span class="keyword">if</span> (promoteCalls) promoteCalls();</span><br><span class="line">      runningCallsCount = runningCallsCount();</span><br><span class="line">      idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runningCallsCount == <span class="number">0</span> &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">      idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>由于 promoteCalls 是true 我们看下 promoteCalls 的方法实现</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> promoteCalls() &#123;</span><br><span class="line">  <span class="keyword">if</span> (runningAsyncCalls.<span class="keyword">size</span>() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Already running max capacity.</span></span><br><span class="line">  <span class="keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="keyword">return</span>; <span class="comment">// No ready calls to promote.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">    AsyncCall <span class="keyword">call</span> = i.<span class="keyword">next</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runningCallsForHost(<span class="keyword">call</span>) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">      i.remove();</span><br><span class="line">      runningAsyncCalls.add(<span class="keyword">call</span>);</span><br><span class="line">      executorService().execute(<span class="keyword">call</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.<span class="keyword">size</span>() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Reached max capacity.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码可以明显看出 ， 当一个请求结束了调用 finished 方法，最终到promoteCalls就是把 异步等待队列中的请求，取出放到 异步执行队列中。</p><ul><li>如果异步执行队列已经是满的状态就不加了，return</li><li>如果 异步等待队列中 没有需要执行的网络请求 也就没有必要进行下一步了 return</li><li>上面的两条都没遇到，遍历 异步等待队列，取出队首的请求，如果这个请求的 host 符合 （正在执行的网络请求中 同一个host最多只能是5个）的这个条件， 把 等待队列的这个请求移除， 加入到 正在执行的队列中， 线程开始执行。 如果不符合继续 遍历操作。</li></ul><h4 id="interceptors-拦截器"><a href="#interceptors-拦截器" class="headerlink" title="interceptors 拦截器"></a>interceptors 拦截器</h4><p>接着看 RealCall 的 getResponseWithInterceptorChain 方法</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span>(<span class="params"></span>) throws IOException</span> &#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//用户自己定义的拦截器</span></span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    <span class="comment">//系统提供的重试拦截器，失败后的重试和重定向</span></span><br><span class="line">    interceptors.<span class="keyword">add</span>(retryAndFollowUpInterceptor);</span><br><span class="line">    <span class="comment">//负责把用户构造的请求转换为发送到服务器的请求 、把服务器返回的响应转换为用户友好的响应 处理 配置请求头等信息</span></span><br><span class="line">    <span class="comment">//从应用程序代码到网络代码的桥梁。首先，它根据用户请求构建网络请求。然后它继续呼叫网络。最后，它根据网络响应构建用户响应。</span></span><br><span class="line">    interceptors.<span class="keyword">add</span>(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    <span class="comment">//处理 缓存配置 根据条件(存在响应缓存并被设置为不变的或者响应在有效期内)返回缓存响应</span></span><br><span class="line">    <span class="comment">//设置请求头(If-None-Match、If-Modified-Since等) 服务器可能返回304(未修改)</span></span><br><span class="line">    <span class="comment">//可配置用户自己设置的缓存拦截器</span></span><br><span class="line">    interceptors.<span class="keyword">add</span>(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    <span class="comment">//连接拦截器 这里才是真正的请求网络</span></span><br><span class="line">    interceptors.<span class="keyword">add</span>(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">    <span class="comment">//配置okhttpClient 时设置的networkInterceptors</span></span><br><span class="line">       <span class="comment">//返回观察单个网络请求和响应的不可变拦截器列表。</span></span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行流操作(写出请求体、获得响应数据) 负责向服务器发送请求数据、从服务器读取响应数据</span></span><br><span class="line">    <span class="comment">//进行http请求报文的封装与请求报文的解析</span></span><br><span class="line">    interceptors.<span class="keyword">add</span>(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"><span class="comment">//创建责任链</span></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(</span><br><span class="line">        interceptors, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>, originalRequest);</span><br><span class="line">        <span class="comment">//执行 责任链</span></span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看下 RealInterceptorChain 的实现</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="line">    Connection connection) throws IOException &#123;</span><br><span class="line"> </span><br><span class="line">  if (index &gt;= interceptors.size()) throw new AssertionError();</span><br><span class="line"></span><br><span class="line">  <span class="attribute">calls++;</span></span><br><span class="line">  //创建新的拦截链，链中的拦截器集合index+1</span><br><span class="line">  RealInterceptorChain next = new RealInterceptorChain(</span><br><span class="line">      interceptors, streamAllocation, httpCodec, connection, index + 1, request);</span><br><span class="line">    //  执行当前的拦截器</span><br><span class="line">  Interceptor interceptor = interceptors.get(index);</span><br><span class="line">  // 执行拦截器</span><br><span class="line">  Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">     if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123;</span><br><span class="line">    throw new IllegalStateException("network interceptor " + interceptor</span><br><span class="line">        + " must call proceed() exactly once");</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Confirm that the intercepted response isn't null.</span><br><span class="line">  if (response == null) &#123;</span><br><span class="line">    throw new NullPointerException("interceptor " + interceptor + " returned null");</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的代码 我们可以看出，新建了一个RealInterceptorChain 责任链 并且 index+1，然后 执行interceptors.get(index); 返回Response。</p><p>责任链中每个拦截器都会执行chain.proceed()方法之前的代码，等责任链最后一个拦截器执行完毕后会返回最终的响应数据，而chain.proceed() 方法会得到最终的响应数据，这时就会执行每个拦截器的chain.proceed()方法之后的代码，其实就是对响应数据的一些操作。</p><p>接下来看下各个拦截器的具体代码</p><h4 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   Request request = chain.request();</span><br><span class="line"></span><br><span class="line">   streamAllocation = <span class="keyword">new</span> StreamAllocation(</span><br><span class="line">       client.connectionPool(), createAddress(request.url()), callStackTrace);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</span><br><span class="line">   Response priorResponse = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">       streamAllocation.release();</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Response response = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">boolean</span> releaseConnection = <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       response = ((RealInterceptorChain) chain).<span class="keyword">proceed</span>(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">       releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">       <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">       <span class="keyword">if</span> (!recover(e.getLastConnectException(), <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">         <span class="keyword">throw</span> e.getLastConnectException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果出现异常 不释放连接， 继续重试</span></span><br><span class="line">       releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">       <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">       <span class="comment">//如果出现异常 不释放连接， 继续重试</span></span><br><span class="line">       <span class="keyword">if</span> (!recover(e, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">       releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">// We're throwing an unchecked exception. Release any resources.</span></span><br><span class="line">       <span class="keyword">if</span> (releaseConnection) &#123;</span><br><span class="line">         streamAllocation.streamFailed(<span class="keyword">null</span>);</span><br><span class="line">         streamAllocation.release();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class="line">     <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">       response = response.newBuilder()</span><br><span class="line">           .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                   .body(<span class="keyword">null</span>)</span><br><span class="line">                   .build())</span><br><span class="line">           .build();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Request followUp = followUpRequest(response);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">         streamAllocation.release();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> response;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     closeQuietly(response.body());</span><br><span class="line"></span><br><span class="line"><span class="comment">//重试次数大于20次 ，不再试了，释放连接，</span></span><br><span class="line">     <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">       streamAllocation.release();</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (followUp.body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;</span><br><span class="line">       streamAllocation.release();</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> HttpRetryException(<span class="string">"Cannot retry streamed HTTP body"</span>, response.code());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">       streamAllocation.release();</span><br><span class="line">       streamAllocation = <span class="keyword">new</span> StreamAllocation(</span><br><span class="line">           client.connectionPool(), createAddress(followUp.url()), callStackTrace);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (streamAllocation.codec() != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Closing the body of "</span> + response</span><br><span class="line">           + <span class="string">" didn't close its backing stream. Bad interceptor?"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     request = followUp;</span><br><span class="line">     priorResponse = response;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当发生 RouteException 和  IOException 都会进行 recover 重试。</p><h4 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">@Override <span class="keyword">public</span> Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">   Request userRequest = chain.request();</span><br><span class="line">   Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">   RequestBody body = userRequest.body();</span><br><span class="line">   <span class="keyword">if</span> (body != <span class="built_in">null</span>) &#123;</span><br><span class="line">     MediaType contentType = body.contentType();</span><br><span class="line">     <span class="keyword">if</span> (contentType != <span class="built_in">null</span>) &#123;</span><br><span class="line">       requestBuilder.<span class="keyword">header</span>(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     long contentLength = body.contentLength();</span><br><span class="line">     <span class="keyword">if</span> (contentLength != <span class="number">-1</span>) &#123;</span><br><span class="line">       requestBuilder.<span class="keyword">header</span>(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</span><br><span class="line">       requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       requestBuilder.<span class="keyword">header</span>(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</span><br><span class="line">       requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (userRequest.<span class="keyword">header</span>(<span class="string">"Host"</span>) == <span class="built_in">null</span>) &#123;</span><br><span class="line">     requestBuilder.<span class="keyword">header</span>(<span class="string">"Host"</span>, hostHeader(userRequest.url(), <span class="literal">false</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (userRequest.<span class="keyword">header</span>(<span class="string">"Connection"</span>) == <span class="built_in">null</span>) &#123;</span><br><span class="line">     requestBuilder.<span class="keyword">header</span>(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span></span><br><span class="line">   <span class="comment">// the transfer stream.</span></span><br><span class="line">   <span class="built_in">boolean</span> transparentGzip = <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">if</span> (userRequest.<span class="keyword">header</span>(<span class="string">"Accept-Encoding"</span>) == <span class="built_in">null</span>) &#123;</span><br><span class="line">     transparentGzip = <span class="literal">true</span>;</span><br><span class="line">     requestBuilder.<span class="keyword">header</span>(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">List</span>&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">   <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</span><br><span class="line">     requestBuilder.<span class="keyword">header</span>(<span class="string">"Cookie"</span>, cookieHeader(cookies));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (userRequest.<span class="keyword">header</span>(<span class="string">"User-Agent"</span>) == <span class="built_in">null</span>) &#123;</span><br><span class="line">     requestBuilder.<span class="keyword">header</span>(<span class="string">"User-Agent"</span>, Version.userAgent());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line"></span><br><span class="line">   HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">   Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">       .request(userRequest);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (transparentGzip</span><br><span class="line">       &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.<span class="keyword">header</span>(<span class="string">"Content-Encoding"</span>))</span><br><span class="line">       &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">     GzipSource responseBody = <span class="literal">new</span> GzipSource(networkResponse.body().source());</span><br><span class="line">     Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">         .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">         .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">         .build();</span><br><span class="line">     responseBuilder.headers(strippedHeaders);</span><br><span class="line">     responseBuilder.body(<span class="literal">new</span> RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>能看出 BridgeInterceptor 主要做的就是<br>在请求发出之前 把请求的 信息拿出来处理成Request.Builder.header 发送出去<br>当请求结果回来之后，处理header 信息。处理返回的信息。</p><p>缓存拦截器</p><h4 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h4><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"> @<span class="type">Override</span> public <span class="type">Response</span> intercept(<span class="type">Chain</span> chain) throws <span class="type">IOException</span> &#123;</span><br><span class="line">    <span class="type">Response</span> cacheCandidate = cache != null</span><br><span class="line">        ? cache.get(chain.request())</span><br><span class="line">        : null;</span><br><span class="line"></span><br><span class="line">    long now = <span class="type">System</span>.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="type">CacheStrategy</span> strategy = <span class="function"><span class="keyword">new</span> <span class="title">CacheStrategy</span>.<span class="title">Factory</span>(now, chain.request(), <span class="title">cacheCandidate</span>).<span class="title">get</span>();</span></span><br><span class="line"><span class="function">    <span class="title">Request</span> <span class="title">networkRequest</span> = <span class="title">strategy</span>.<span class="title">networkRequest</span>;</span></span><br><span class="line"><span class="function">    <span class="title">Response</span> <span class="title">cacheResponse</span> = <span class="title">strategy</span>.<span class="title">cacheResponse</span>;</span></span><br><span class="line"><span class="function"><span class="comment">//如果networkRequest == null 则说明不使用网络请求</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取缓存中（CacheStrategy）的Response</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> (cache != null) &#123;</span></span><br><span class="line"><span class="function">      <span class="title">cache</span>.<span class="title">trackResponse</span>(strategy);</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//缓存无效 关闭资源</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</span></span><br><span class="line"><span class="function">      <span class="title">closeQuietly</span>(cacheCandidate.body()); <span class="comment">// The cache candidate wasn't applicable. Close it.</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// If we're forbidden from using the network and the cache is insufficient, fail.</span></span></span><br><span class="line"><span class="function">    <span class="comment">//networkRequest == null 不使用网络请求 且没有缓存 cacheResponse == null  返回失败</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> (networkRequest == null &amp;&amp; cacheResponse == null) &#123;</span></span><br><span class="line"><span class="function">      <span class="title">return</span> <span class="title">new</span> <span class="title">Response</span>.<span class="title">Builder</span>()</span></span><br><span class="line"><span class="function">          .<span class="title">request</span>(chain.request())</span></span><br><span class="line"><span class="function">          .<span class="title">protocol</span>(<span class="type">Protocol</span>.<span class="type">HTTP_1_1</span>)</span></span><br><span class="line"><span class="function">          .<span class="title">code</span>(<span class="number">504</span>)</span></span><br><span class="line"><span class="function">          .<span class="title">message</span>("<span class="type">Unsatisfiable</span> <span class="type">Request</span> (only-if-cached)")</span></span><br><span class="line"><span class="function">          .<span class="title">body</span>(<span class="type">Util</span>.<span class="type">EMPTY_RESPONSE</span>)</span></span><br><span class="line"><span class="function">          .<span class="title">sentRequestAtMillis</span>(<span class="number">-1</span>L)</span></span><br><span class="line"><span class="function">          .<span class="title">receivedResponseAtMillis</span>(<span class="type">System</span>.currentTimeMillis())</span></span><br><span class="line"><span class="function">          .<span class="title">build</span>();</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// If we don't need the network, we're done.</span></span></span><br><span class="line"><span class="function">    <span class="comment">//如果无需网络请求， 把缓存中的结果取出来组装成返回体 返回</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> (networkRequest == null) &#123;</span></span><br><span class="line"><span class="function">      <span class="title">return</span> <span class="title">cacheResponse</span>.<span class="title">newBuilder</span>()</span></span><br><span class="line"><span class="function">          .<span class="title">cacheResponse</span>(stripBody(cacheResponse))</span></span><br><span class="line"><span class="function">          .<span class="title">build</span>();</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">Response</span> <span class="title">networkResponse</span> = <span class="title">null</span>;</span></span><br><span class="line"><span class="function">    <span class="title">try</span> &#123;</span></span><br><span class="line"><span class="function">   <span class="comment">//进行网络请求</span></span></span><br><span class="line"><span class="function">      <span class="title">networkResponse</span> = <span class="title">chain</span>.<span class="title">proceed</span>(networkRequest);</span></span><br><span class="line"><span class="function">    &#125; <span class="title">finally</span> &#123;</span></span><br><span class="line"><span class="function">      <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></span></span><br><span class="line"><span class="function">      <span class="title">if</span> (networkResponse == null &amp;&amp; cacheCandidate != null) &#123;</span></span><br><span class="line"><span class="function">        <span class="title">closeQuietly</span>(cacheCandidate.body());</span></span><br><span class="line"><span class="function">      &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//网络请求结果回来了，根据情况更新缓存结果</span></span></span><br><span class="line"><span class="function">    <span class="comment">// If we have a cache response too, then we're doing a conditional get.</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> (cacheResponse != null) &#123;</span></span><br><span class="line"><span class="function">      <span class="title">if</span> (networkResponse.code() == <span class="title">HTTP_NOT_MODIFIED</span>) &#123;</span></span><br><span class="line"><span class="function">        <span class="title">Response</span> <span class="title">response</span> = <span class="title">cacheResponse</span>.<span class="title">newBuilder</span>()</span></span><br><span class="line"><span class="function">            .<span class="title">headers</span>(combine(cacheResponse.headers(), <span class="title">networkResponse</span>.<span class="title">headers</span>()))</span></span><br><span class="line"><span class="function">            .<span class="title">sentRequestAtMillis</span>(networkResponse.sentRequestAtMillis())</span></span><br><span class="line"><span class="function">            .<span class="title">receivedResponseAtMillis</span>(networkResponse.receivedResponseAtMillis())</span></span><br><span class="line"><span class="function">            .<span class="title">cacheResponse</span>(stripBody(cacheResponse))</span></span><br><span class="line"><span class="function">            .<span class="title">networkResponse</span>(stripBody(networkResponse))</span></span><br><span class="line"><span class="function">            .<span class="title">build</span>();</span></span><br><span class="line"><span class="function">        <span class="title">networkResponse</span>.<span class="title">body</span>().<span class="title">close</span>();</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="comment">// Update the cache after combining headers but before stripping the</span></span></span><br><span class="line"><span class="function">        <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span></span><br><span class="line"><span class="function">        <span class="title">cache</span>.<span class="title">trackConditionalCacheHit</span>();</span></span><br><span class="line"><span class="function">        <span class="title">cache</span>.<span class="title">update</span>(cacheResponse, response);</span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">response</span>;</span></span><br><span class="line"><span class="function">      &#125; <span class="title">else</span> &#123;</span></span><br><span class="line"><span class="function">        <span class="title">closeQuietly</span>(cacheResponse.body());</span></span><br><span class="line"><span class="function">      &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">Response</span> <span class="title">response</span> = <span class="title">networkResponse</span>.<span class="title">newBuilder</span>()</span></span><br><span class="line"><span class="function">        .<span class="title">cacheResponse</span>(stripBody(cacheResponse))</span></span><br><span class="line"><span class="function">        .<span class="title">networkResponse</span>(stripBody(networkResponse))</span></span><br><span class="line"><span class="function">        .<span class="title">build</span>();</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">if</span> (<span class="type">HttpHeaders</span>.hasBody(response)) &#123;</span></span><br><span class="line"><span class="function">      <span class="title">CacheRequest</span> <span class="title">cacheRequest</span> = <span class="title">maybeCache</span>(response, networkResponse.request(), <span class="title">cache</span>);</span></span><br><span class="line"><span class="function">      <span class="title">response</span> = <span class="title">cacheWritingResponse</span>(cacheRequest, response);</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">response</span>;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br></pre></td></tr></table></figure><p>如果用户自己配置了缓存拦截器，cacheCandidate = cache.Response 获取用户自己存储的Response,否则 cacheCandidate = null;同时从CacheStrategy 获取cacheResponse 和 networkRequest</p><p>如果cacheCandidate ！= null 而 cacheResponse == null 说明缓存无效清除cacheCandidate缓存。</p><p>如果networkRequest == null 说明没有网络，cacheResponse == null 没有缓存，返回失败的信息，责任链此时也就终止，不会在往下继续执行。</p><p>如果networkRequest == null 说明没有网络，cacheResponse != null 有缓存，返回缓存的信息，责任链此时也就终止，不会在往下继续执行。</p><p>然后</p><p>执行下一个拦截器，也就是请求网络</p><p>责任链执行完毕后，会返回最终响应数据，如果缓存存在更新缓存，如果缓存不存在加入到缓存中去。</p><h4 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h4><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">    // We need the network to satisfy this request. Possibly for validating a conditional GET.</span><br><span class="line">    boolean doExtensiveHealthChecks = !request.method().equals(<span class="string">"<span class="keyword">GET</span>"</span>);</span><br><span class="line">    HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);</span><br><span class="line">    RealConnection connection = streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">    return realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>连接复用的逻辑就是这里面， 寻找可用的链接， 复用， 这个待会分析。</p><h4 id="networkInterceptors"><a href="#networkInterceptors" class="headerlink" title="networkInterceptors"></a>networkInterceptors</h4><p>这个是自定义的网络拦截器</p><h4 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">@Override public Response intercept(Chain chain) throws IOException &#123;</span></span><br><span class="line">//HttpStream 就是先前在 ConnectInterceptor 创建出来的</span><br><span class="line">    HttpCodec httpCodec = ((RealInterceptorChain) chain).httpStream()<span class="comment">;</span></span><br><span class="line">    <span class="keyword">StreamAllocation </span><span class="keyword">streamAllocation </span>= ((RealInterceptorChain) chain).<span class="keyword">streamAllocation();</span></span><br><span class="line"><span class="keyword"> </span>   Request request = chain.request()<span class="comment">;</span></span><br><span class="line">/发送请求的时间戳</span><br><span class="line">    long sentRequestMillis = System.currentTimeMillis()<span class="comment">;</span></span><br><span class="line">    //写入请求头信息</span><br><span class="line">    httpCodec.writeRequestHeaders(request)<span class="comment">;</span></span><br><span class="line">//写入请求体信息（有请求体的情况）</span><br><span class="line">    <span class="meta">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.<span class="keyword">body() </span>!= null) &#123;</span><br><span class="line">      Sink requestBodyOut = httpCodec.createRequestBody(request, request.<span class="keyword">body().contentLength());</span></span><br><span class="line"><span class="keyword"> </span>     <span class="keyword">BufferedSink </span><span class="keyword">bufferedRequestBody </span>= Okio.<span class="keyword">buffer(requestBodyOut);</span></span><br><span class="line"><span class="keyword"> </span>     request.<span class="keyword">body().writeTo(bufferedRequestBody);</span></span><br><span class="line"><span class="keyword"> </span>     <span class="keyword">bufferedRequestBody.close();</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">//结束请求</span><br><span class="line">    httpCodec.finishRequest()<span class="comment">;</span></span><br><span class="line">//读取响应头信息</span><br><span class="line">    Response response = httpCodec.readResponseHeaders()</span><br><span class="line">        .request(request)</span><br><span class="line">        //握手？</span><br><span class="line">        .handshake(<span class="keyword">streamAllocation.connection().handshake())</span></span><br><span class="line"><span class="keyword"> </span>       .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .<span class="keyword">build();</span></span><br><span class="line"><span class="keyword"> </span>//openResponseBody 获取响应体信息</span><br><span class="line">    int <span class="meta">code</span> = response<span class="meta">.code</span>()<span class="comment">;</span></span><br><span class="line">    //app 不走这个</span><br><span class="line">    <span class="meta">if</span> (forWebSocket &amp;&amp; <span class="meta">code</span> == <span class="number">101</span>) &#123;</span><br><span class="line">      // Connection is upgrading, <span class="keyword">but </span>we need to ensure interceptors see a non-null response <span class="keyword">body.</span></span><br><span class="line"><span class="keyword"> </span>     response = response.newBuilder()</span><br><span class="line">          .<span class="keyword">body(Util.EMPTY_RESPONSE)</span></span><br><span class="line"><span class="keyword"> </span>         .<span class="keyword">build();</span></span><br><span class="line"><span class="keyword"> </span>   &#125; <span class="meta">else</span> &#123;</span><br><span class="line">      response = response.newBuilder()</span><br><span class="line">          .<span class="keyword">body(httpCodec.openResponseBody(response))</span></span><br><span class="line"><span class="keyword"> </span>         .<span class="keyword">build();</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</span><br><span class="line">        <span class="title">||</span> <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</span><br><span class="line">      <span class="keyword">streamAllocation.noNewStreams();</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">if</span> ((<span class="meta">code</span> == <span class="number">204</span> <span class="title">||</span> <span class="meta">code</span> == <span class="number">205</span>) &amp;&amp; response.<span class="keyword">body().contentLength() </span>&gt; <span class="number">0</span>) &#123;</span><br><span class="line">      throw new ProtocolException(</span><br><span class="line">          <span class="string">"HTTP "</span> + <span class="meta">code</span> + <span class="string">" had non-zero Content-Length: "</span> + response.<span class="keyword">body().contentLength());</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line"></span><br><span class="line">    return response<span class="comment">;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>OkhttpClient 实现了Call.Fctory,负责为Request 创建 Call；</p><p>RealCall 为Call的具体实现，其enqueue() 异步请求接口通过Dispatcher()调度器利用ExcutorService实现，而最终进行网络请求时和同步的execute()接口一致，都是通过 getResponseWithInterceptorChain() 函数实现</p><p>getResponseWithInterceptorChain() 中利用 Interceptor 链条，责任链模式 分层实现缓存、透明压缩、网络 IO 等功能；最终将响应数据返回给用户。</p><h3 id="OkHttp-连接池复用"><a href="#OkHttp-连接池复用" class="headerlink" title="OkHttp 连接池复用"></a>OkHttp 连接池复用</h3><p>我们知道 OkHttp 支持5个并发 socket 连接，默认keepAlive 时间为5分钟。 那究竟是怎么做到的呢</p><p>在 ConnectInterceptor 中我们知道 newStream</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> HttpCodec <span class="keyword">new</span><span class="type">Stream</span>(OkHttpClient client, boolean doExtensiveHealthChecks) &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    找“健康的”RealConnection</span><br><span class="line">      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line"></span><br><span class="line">      HttpCodec resultCodec;</span><br><span class="line">      <span class="keyword">if</span> (resultConnection.http2Connection != <span class="literal">null</span>) &#123;</span><br><span class="line">        resultCodec = <span class="keyword">new</span> <span class="type">Http2Codec</span>(client, <span class="built_in">this</span>, resultConnection.http2Connection);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 通过RealConnection创建HttpCodec</span></span><br><span class="line">        resultConnection.socket().setSoTimeout(readTimeout);</span><br><span class="line">        resultConnection.source.timeout().timeout(readTimeout, MILLISECONDS);</span><br><span class="line">        resultConnection.sink.timeout().timeout(writeTimeout, MILLISECONDS);</span><br><span class="line">        resultCodec = <span class="keyword">new</span> <span class="type">Http1Codec</span>(</span><br><span class="line">            client, <span class="built_in">this</span>, resultConnection.source, resultConnection.sink);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      synchronized (connectionPool) &#123;</span><br><span class="line">        codec = resultCodec;</span><br><span class="line">        <span class="keyword">return</span> resultCodec;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RouteException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span> RealConnection findHealthyConnection(int connectTimeout, int readTimeout,</span><br><span class="line">      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)</span><br><span class="line">      throws IOException &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// while循环直到找到return</span></span><br><span class="line">      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class="line">          connectionRetryEnabled);</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line">     </span><br><span class="line">      <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,</span><br><span class="line">      boolean connectionRetryEnabled) throws IOException &#123;</span><br><span class="line">    Route selectedRoute;</span><br><span class="line">    synchronized (connectionPool) &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 如果为空，尝试从连接池中获取，这个方法的关键点，如果获取到connection不为空（第三个参数为this，找到合适的RealConnection赋值到connection</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Attempt to get a connection from the pool.</span></span><br><span class="line">      RealConnection pooledConnection = Internal.instance.<span class="keyword">get</span>(connectionPool, address, <span class="built_in">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (pooledConnection != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.connection = pooledConnection;</span><br><span class="line">        <span class="keyword">return</span> pooledConnection;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      selectedRoute = route;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (selectedRoute == <span class="literal">null</span>) &#123;</span><br><span class="line">      selectedRoute = routeSelector.next();</span><br><span class="line">      synchronized (connectionPool) &#123;</span><br><span class="line">        route = selectedRoute;</span><br><span class="line">        refusedStreamCount = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有找到，则创建一个</span></span><br><span class="line">    RealConnection <span class="keyword">new</span><span class="type">Connection</span> = <span class="keyword">new</span> <span class="type">RealConnection</span>(selectedRoute);</span><br><span class="line"></span><br><span class="line">    synchronized (connectionPool) &#123;</span><br><span class="line">      acquire(<span class="keyword">new</span><span class="type">Connection</span>);</span><br><span class="line">      Internal.instance.put(connectionPool, <span class="keyword">new</span><span class="type">Connection</span>);</span><br><span class="line">      <span class="built_in">this</span>.connection = <span class="keyword">new</span><span class="type">Connection</span>;</span><br><span class="line">      <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IOException</span>(<span class="string">"Canceled"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 进行实际的的网络连接</span></span><br><span class="line">    <span class="keyword">new</span><span class="type">Connection</span>.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(),</span><br><span class="line">        connectionRetryEnabled);</span><br><span class="line">    routeDatabase().connected(<span class="keyword">new</span><span class="type">Connection</span>.route());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Connection</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从上面的分析，获取RealConnection的流程，总结如下：</p><p>在ConnectInterceptor中获取StreamAllocation的引用，通过StreamAllocation去寻找RealConnection</p><p>如果RealConnection不为空，那么直接返回。否则去连接池中寻找并返回，如果找不到直接创建并设置到连接池中，然后再进一步判断是否重复释放到Socket。</p><p>在实际网络连接connect中，选择不同的链接方式（有隧道链接（Tunnel）和管道链接（Socket））<br>把RealConnection和HttpCodec传递给下一个拦截器</p><p><strong>在从连接池中获取一个连接的时候，使用了 Internal 的 get() 方法。Internal 有一个静态的实例，会在 OkHttpClient 的静态代码快中被初始化。我们会在 Internal 的 get() 中调用连接池的 get() 方法来得到一个连接。并且，从中我们明白了连接复用的一个好处就是省去了进行 TCP 和 TLS 握手的一个过程。因为建立连接本身也是需要消耗一些时间的，连接被复用之后可以提升我们网络访问的效率。</strong></p><h4 id="ConnectionPool"><a href="#ConnectionPool" class="headerlink" title="ConnectionPool"></a>ConnectionPool</h4><p>连接池的位于 ConnectionPool 中</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 空闲 socket 最大连接数 */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxIdleConnections;</span><br><span class="line"> socket 的 keepAlive 时间</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> keepAliveDurationNs;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealConnection&gt; connections = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"> <span class="keyword">final</span> RouteDatabase routeDatabase = <span class="keyword">new</span> RouteDatabase();</span><br><span class="line"> <span class="keyword">boolean</span> cleanupRunning;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>(<span class="number">5</span>, <span class="number">5</span>, TimeUnit.MINUTES);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> maxIdleConnections, <span class="keyword">long</span> keepAliveDuration, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.maxIdleConnections = maxIdleConnections;</span><br><span class="line">   <span class="keyword">this</span>.keepAliveDurationNs = timeUnit.toNanos(keepAliveDuration);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Put a floor on the keep alive duration, otherwise cleanup will spin loop.</span></span><br><span class="line">   <span class="keyword">if</span> (keepAliveDuration &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"keepAliveDuration &lt;= 0: "</span> + keepAliveDuration);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>构造方法可以看到，空闲socket的最大连接数为5个，ConnectionPool是在 OkHttpClient 实例化时创建的。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RealConnection <span class="builtin-name">get</span>(Address address, StreamAllocation streamAllocation) &#123;</span><br><span class="line">   assert (Thread.holdsLock(this));</span><br><span class="line">   <span class="keyword">for</span> (RealConnection<span class="built_in"> connection </span>: connections) &#123;</span><br><span class="line">     <span class="keyword">if</span> (connection.allocations.size() &lt; connection.allocationLimit</span><br><span class="line">         &amp;&amp; address.equals(connection.route().address)</span><br><span class="line">         &amp;&amp; !connection.noNewStreams) &#123;</span><br><span class="line">       streamAllocation.acquire(connection);</span><br><span class="line">       return connection;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void put(RealConnection connection) &#123;</span><br><span class="line">   assert (Thread.holdsLock(this));</span><br><span class="line">   <span class="keyword">if</span> (!cleanupRunning) &#123;</span><br><span class="line">     cleanupRunning = <span class="literal">true</span>;</span><br><span class="line">     executor.execute(cleanupRunnable);</span><br><span class="line">   &#125;</span><br><span class="line">   添加到 Deque 之前需要清理空闲的线程，</span><br><span class="line">   connections.<span class="builtin-name">add</span>(connection);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>看下 put，get 方法，get 方法会遍历 connection 缓存列表， 当某个连接计数小于限制的大小，并且 request 的地址和缓存列表中此链接的地址完全匹配时， 则直接复用缓存列表中的 connection 作为request 的连接。 </p><p>上面可以看到 put 方法会调用清理线程。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class="line">      <span class="keyword">if</span> (waitNanos == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000</span>L;</span><br><span class="line">        waitNanos -= (waitMillis * <span class="number">1000000</span>L);</span><br><span class="line">        <span class="keyword">synchronized</span> (ConnectionPool.<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            ConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">线程会不停的调用cleanup方法进行清理， 并返回下次需要清理的间隔时间， 然后调用 wait方法进行等待，当时间到了之后再次进行清理。 一直这样下去。</span><br><span class="line"></span><br><span class="line">会调用 cleanup方法，下面是cleanup方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>;</span><br><span class="line">  RealConnection longestIdleConnection = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find either a connection to evict, or the time that the next eviction is due.</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      RealConnection connection = i.next();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If the connection is in use, keep searching.</span></span><br><span class="line">      <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        inUseConnectionCount++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      idleConnectionCount++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If the connection is ready to be evicted, we're done.</span></span><br><span class="line">      <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">      <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">        longestIdleDurationNs = idleDurationNs;</span><br><span class="line">        longestIdleConnection = connection;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</span><br><span class="line">        || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</span><br><span class="line">      <span class="comment">// We've found a connection to evict. Remove it from the list, then close it below (outside</span></span><br><span class="line">      <span class="comment">// of the synchronized block).</span></span><br><span class="line">      connections.remove(longestIdleConnection);</span><br><span class="line">    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(idleConnectionCount &gt; <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// A connection will be ready to evict soon.</span></span><br><span class="line">      <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(inUseConnectionCount &gt; <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// All connections are in use. It'll be at least the keep alive duration 'til we run again.</span></span><br><span class="line">      <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// No connections, idle or in use.</span></span><br><span class="line">      cleanupRunning = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  closeQuietly(longestIdleConnection.socket());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cleanup again immediately.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cleanup方法的过程是 根据连接中的引用计数来计算空闲连接数和活跃连接数，，然后标记出空闲连接数。<br>如果空闲连接keepAlive 时间超过5分钟，或者空闲连接数超过5个，则从Deque 中移除次连接，<br>如果空闲连接数大于0，则返回此连接即将到期的时间，如果都是活跃连接，并大于0，则返回5分钟。 如果没有任何连接，则返回-1，</p><p>清除算法，使用类似GC中的引用计算算法，如果弱引用StreamAllocation列表为0，则表示空闲需要进行回收。</p><p>可以看出连接池复用的核心就是用 Deque<realconnection> 来存储连接， 通过 put，get 等来对 Deque 进行操作， 另外通过判断连接中的技术对象 StreamAllocation 来进行自动回收连接。</realconnection></p><h3 id="OkHttp-的优缺点"><a href="#OkHttp-的优缺点" class="headerlink" title="OkHttp 的优缺点"></a>OkHttp 的优缺点</h3><p>优点：</p><ul><li>1、支持 HTTP/2，允许连接同一主机的所有请求分享一个 socket。 如果 HTTP/2 不可用，会使用连接池减少请求延迟。</li><li>2、使用GZIP压缩下载内容，且压缩操作对用户是透明的。</li><li>3、利用响应缓存来避免重复的网络请求。</li><li>4、如果你的服务端有多个IP地址，当第一个地址连接失败时，OKHttp会尝试连接其他的地址，这对IPV4和IPV6以及寄宿在多个数据中心的服务而言，是非常有必要的。</li><li>5、用户可自主定制拦截器，实现自己想要的网络拦截。</li><li>6、支持大文件的上传和下载。</li><li>7、支持cookie持久化。</li><li>8、支持自签名的https链接，配置有效证书即可。</li><li>9、支持Headers的缓存策略减少重复的网络请求。</li></ul><p>缺点：</p><ul><li>1、网络请求的回调是子线程，需要用户手动操作发送到主线程。</li><li>2、参数较多，配置起来复杂。</li></ul><p>所以综合上面的缺点，OkHttpUtils 及类似的 封装应用而生。下一篇我们来通过 <a href="https://youngerdev.com/OkHttpUtils-源码解析.html">OkHttpUtils源码解析</a> 看下是如何封装并解决这些问题的。</p><h3 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h3><ul><li><a href="https://item.jd.com/12125491.html" target="_blank" rel="noopener">Android 进阶之光</a></li><li><a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/index.html" target="_blank" rel="noopener">https://blog.piasy.com/2016/07/11/Understand-OkHttp/index.html</a></li><li><a href="https://juejin.im/post/5c1b23b9e51d4529096aaaee" target="_blank" rel="noopener">https://juejin.im/post/5c1b23b9e51d4529096aaaee</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接上篇的 &lt;a href=&quot;https://youngerdev.com/Volley-源码解析.html&quot;&gt;Volley 源码&lt;/a&gt;解析，目前项目中更多的用到的是 &lt;a href=&quot;https://github.com/hongyangAndroid/okhttputi
      
    
    </summary>
    
    
      <category term="源码" scheme="http://youngerdev.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="OkHttp源码" scheme="http://youngerdev.com/tags/OkHttp%E6%BA%90%E7%A0%81/"/>
    
      <category term="OkHttpUtils源码" scheme="http://youngerdev.com/tags/OkHttpUtils%E6%BA%90%E7%A0%81/"/>
    
      <category term="源码解析" scheme="http://youngerdev.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android 源码" scheme="http://youngerdev.com/tags/Android-%E6%BA%90%E7%A0%81/"/>
    
      <category term="网络请求" scheme="http://youngerdev.com/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
      <category term="Android网络" scheme="http://youngerdev.com/tags/Android%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Volley 源码解析</title>
    <link href="http://youngerdev.com/Volley-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html"/>
    <id>http://youngerdev.com/Volley-源码解析.html</id>
    <published>2019-10-07T04:30:44.000Z</published>
    <updated>2019-10-08T00:39:29.595Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Volley-源码解析"><a href="#Volley-源码解析" class="headerlink" title="Volley 源码解析"></a>Volley 源码解析</h2><h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><p>目前已经有很多文章写volley源码解析的了， </p><p>为什么这么多呢？ 可能是因为volley 的源码相对来说比较少， 逻辑相对简单，好读。 </p><p>为什么我还要写volley源码解析呢？ 和上面的问题的原因一样， 还有就是我也读了好几遍volley的源码了，每次读完后过段时间就会忘记一些，应了那句老话，“好记性不如烂笔头”，现在也不用纸笔了，直接电脑上敲出来，更方便。 我不一定写的比其他同学的高明，但是我会尽量写出我的理解，和现实工作内容联系起来书写。</p><p><a href="https://github.com/google/volley" target="_blank" rel="noopener">注意本文是基于volley最新版本 1.1版本源码</a></p><p>本文的目录结构是：</p><ul><li>volley 的基本使用</li><li>volley 源码解析</li><li>volley 的优缺点</li><li>volley 的扩展</li></ul><h3 id="volley-基本使用"><a href="#volley-基本使用" class="headerlink" title="volley 基本使用"></a>volley 基本使用</h3><p>Volley 是 Google 推出的 Android 异步网络请求框架和图片加载框架。在 Google I/O 2013 大会上发布。</p><p>特别适合数据量小，通信频繁的网络操作</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在项目的gradle 文件中添加依赖</span><br><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">implementation</span> <span class="string">'com.android.volley:volley:1.1.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用起来很简单，举一个StringRequest例子，其他的类似</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//构建一个请求队列</span></span><br><span class="line">RequestQueue queue = Volley.<span class="keyword">new</span><span class="type">RequestQueue</span>(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">String</span> url =<span class="string">"http://www.baidu.com"</span>;</span><br><span class="line"><span class="comment">//创建一个request        </span></span><br><span class="line">StringRequest stringRequest = <span class="keyword">new</span> <span class="type">StringRequest</span>(com.android.volley.Request.Method.GET,url, <span class="keyword">new</span> <span class="type">com</span>.android.volley.Response.Listener&lt;<span class="keyword">String</span>&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> void onResponse(<span class="keyword">String</span> response) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> <span class="type">com</span>.android.volley.Response.ErrorListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> void onErrorResponse(VolleyError error) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把request 添加到 队列中        </span></span><br><span class="line">queue.add(stringRequest);</span><br></pre></td></tr></table></figure><p><img src="https://developer.android.google.cn/images/training/volley-request.png" alt="volley源码架构图"></p><h3 id="volley-源码解析"><a href="#volley-源码解析" class="headerlink" title="volley 源码解析"></a>volley 源码解析</h3><p>首先我们看下请求队列的创建。</p><h4 id="Volley"><a href="#Volley" class="headerlink" title="Volley"></a>Volley</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RequestQueue<span class="built_in"> queue </span>= Volley.newRequestQueue(this);</span><br></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="keyword">new</span><span class="type">RequestQueue</span>(Context context) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span><span class="type">RequestQueue</span>(context, (BaseHttpStack) <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">重载 <span class="keyword">new</span><span class="type">RequestQueue</span> 方法</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="keyword">new</span><span class="type">RequestQueue</span>(Context context, BaseHttpStack stack) &#123;</span><br><span class="line">        BasicNetwork network;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (stack == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">                network = <span class="keyword">new</span> <span class="type">BasicNetwork</span>(<span class="keyword">new</span> <span class="type">HurlStack</span>());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">String</span> userAgent = <span class="string">"volley/0"</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">String</span> packageName = context.getPackageName();</span><br><span class="line">                    PackageInfo info =</span><br><span class="line">                            context.getPackageManager().getPackageInfo(packageName, <span class="comment">/* flags= */</span> <span class="number">0</span>);</span><br><span class="line">                    userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                network =</span><br><span class="line">                        <span class="keyword">new</span> <span class="type">BasicNetwork</span>(</span><br><span class="line">                                <span class="keyword">new</span> <span class="type">HttpClientStack</span>(AndroidHttpClient.<span class="keyword">new</span><span class="type">Instance</span>(userAgent)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            network = <span class="keyword">new</span> <span class="type">BasicNetwork</span>(stack);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span><span class="type">RequestQueue</span>(context, network);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最终调用这个方法start</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RequestQueue <span class="keyword">new</span><span class="type">RequestQueue</span>(Context context, Network network) &#123;</span><br><span class="line">    <span class="comment">//创建缓存目录</span></span><br><span class="line">        File cacheDir = <span class="keyword">new</span> <span class="type">File</span>(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line">        <span class="comment">//创建任务队列</span></span><br><span class="line">        RequestQueue queue = <span class="keyword">new</span> <span class="type">RequestQueue</span>(<span class="keyword">new</span> <span class="type">DiskBasedCache</span>(cacheDir), network);</span><br><span class="line">        <span class="comment">//启动队列</span></span><br><span class="line">        queue.start();</span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>先判断是否有指定 stack 也就是实际请求的方式，如果有传进来，就用传的来指定的方式，<br>如果为空， 就按照sdk 版本创建相应的请求方式， sdk版本&lt;9的使用 httpClient 请求 </p><p>大于等于9的使用 httpUrlconnection 来请求，这是因为，httpUrlconnection在Android 2.2之前有bug。但是httpClient 没有 httpUrlconnection 性能好， Api简单，体积较小，压缩和缓存机制也可有效减少网络访问的流量， 而且httpclient 请求的方式 在Android6.0之后也直接从sdk 中直接去掉了。</p><h4 id="RequestQueue"><a href="#RequestQueue" class="headerlink" title="RequestQueue"></a>RequestQueue</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public RequestQueue(Cache cache,<span class="built_in"> Network </span>network, int threadPoolSize) &#123;</span><br><span class="line">       this(</span><br><span class="line">               cache,</span><br><span class="line">               network,</span><br><span class="line">               threadPoolSize,</span><br><span class="line">               new ExecutorDelivery(new Handler(Looper.getMainLooper())));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以重点关注 ExecutorDelivery(new Handler(Looper.getMainLooper())))<br>接下来在线程切换地方法讲到它，这个是成功把子线程数据发送到主线程的关键  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">任务队列的启动方法</span><br><span class="line">    <span class="comment">/** Starts the dispatchers in this queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stop(); <span class="comment">// Make sure any currently running dispatchers are stopped.</span></span><br><span class="line">        <span class="comment">// Create the cache dispatcher and start it.</span></span><br><span class="line">        <span class="comment">//创建了一个缓存调度线程 并启动</span></span><br><span class="line">        mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">        mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create network dispatchers (and corresponding threads) up to the pool size.</span></span><br><span class="line">        <span class="comment">//创建了4个网络调度线程，并启动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">            NetworkDispatcher networkDispatcher =</span><br><span class="line">                    <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery);</span><br><span class="line">            mDispatchers[i] = networkDispatcher;</span><br><span class="line">            networkDispatcher.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>任务队列创建完成，等到request 加入，request的创建比较简单，可以根据自己的需求创建相应的request ，系统提供了 String ，Image， JsonObject ，jsonArray 等request，他们的区别主要是在 parseNetworkResponse 方法中根据不同的数据类型，进行相应数据类型的解析。</p><p>再看网络请求的 add 方法，就是把request 添加到 任务队列中</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Request&lt;T&gt; <span class="built_in">add</span>(Request&lt;T&gt; request) &#123;</span><br><span class="line">    <span class="comment">// Tag the request as belonging to this queue and add it to the set of current requests.</span></span><br><span class="line">    request.setRequestQueue(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</span><br><span class="line">        mCurrentRequests.<span class="built_in">add</span>(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process requests in the order they are added.</span></span><br><span class="line">    request.setSequence(getSequenceNumber());</span><br><span class="line">    request.addMarker(<span class="string">"add-to-queue"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断这个 request 是否支持缓存, 如果不支持就直接 把这个request加入到网络调度线程中        </span></span><br><span class="line">    <span class="comment">//否则就加入到缓存 调度线程。</span></span><br><span class="line">    <span class="keyword">if</span> (!request.shouldCache()) &#123;</span><br><span class="line">        mNetworkQueue.<span class="built_in">add</span>(request);</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line">    mCacheQueue.<span class="built_in">add</span>(request);</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 mNetworkQueue 和 mCacheQueue  都是 PriorityBlockingQueue 优先级阻塞队列 现在根据情况分别加入到相应的调度线程等待执行</p><h4 id="CacheDispatcher"><a href="#CacheDispatcher" class="headerlink" title="CacheDispatcher"></a>CacheDispatcher</h4><p>上面已经把request加入到缓存队列中了，接下来看下 CacheDispatcher 是如何处理这些request的。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">CacheDispatcher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能看到这个 CacheDispatcher 继承 Thread ，前面我们也看到start 方法中已经 调用了线程的 start（） ，那我们看下run方法</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">@Override</span></span><br><span class="line"> public void run() &#123;</span><br><span class="line">     <span class="selector-tag">if</span> (DEBUG) <span class="selector-tag">VolleyLog</span><span class="selector-class">.v</span>(<span class="string">"start new dispatcher"</span>);</span><br><span class="line">     <span class="selector-tag">Process</span><span class="selector-class">.setThreadPriority</span>(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Make a blocking call to initialize the cache.</span></span><br><span class="line">     <span class="selector-tag">mCache</span><span class="selector-class">.initialize</span>();</span><br><span class="line"></span><br><span class="line">     <span class="selector-tag">while</span> (true) &#123;</span><br><span class="line">         <span class="selector-tag">try</span> &#123;</span><br><span class="line">             <span class="selector-tag">processRequest</span>();</span><br><span class="line">         &#125; <span class="selector-tag">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             <span class="comment">// We may have been interrupted because it was time to quit.</span></span><br><span class="line">             <span class="selector-tag">if</span> (mQuit) &#123;</span><br><span class="line">                 <span class="selector-tag">Thread</span><span class="selector-class">.currentThread</span>()<span class="selector-class">.interrupt</span>();</span><br><span class="line">                 <span class="selector-tag">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="selector-tag">VolleyLog</span><span class="selector-class">.e</span>(</span><br><span class="line">                     <span class="string">"Ignoring spurious interrupt of CacheDispatcher thread; "</span></span><br><span class="line">                             + <span class="string">"use quit() to terminate it"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>能看到代码相当简洁， 就是一个 while (true) 死循环， 里面执行 processRequest方法，</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// Get a request from the cache triage queue, blocking until</span></span><br><span class="line">    <span class="comment">// at least one is available.</span></span><br><span class="line">    <span class="keyword">final</span> Request&lt;?&gt; request = mCacheQueue.take();</span><br><span class="line">    processRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>英文注释写的也特别清楚，就是从 BlockingQueue阻塞队列中取出，如果有数据就处理，没有数据就阻塞在这。</p><h5 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h5><p>如果BlockQueue是空的，从BlockingQueue取东西的操作将会被阻断进入等待状态，直到BlockingQueue进了东西才会被唤醒。</p><p>同样，如果BlockingQueue是满的，任何试图往里存东西的操作也会被阻断进入等待状态，直到BlockingQueue里有空间才会被唤醒继续操作。</p><p>了解了 BlockingQueue 我们看下真正处理request的详细方法</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(<span class="keyword">final</span> Request&lt;?&gt; request)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        request.addMarker(<span class="string">"cache-queue-take"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先判断这个request是否已经被取消，需求就不继续了，直接调用finish 方法</span></span><br><span class="line">        <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">            request.finish(<span class="string">"cache-discard-canceled"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试从缓存中查找是否有同样的request在</span></span><br><span class="line">        Cache.Entry entry = mCache.get(request.getCacheKey());</span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            request.addMarker(<span class="string">"cache-miss"</span>);</span><br><span class="line">            <span class="comment">// 如果没有缓存，就加入到网络请求的队列</span></span><br><span class="line">            <span class="keyword">if</span> (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">                mNetworkQueue.put(request);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果缓存已经过期，也加入到网络请求的队列</span></span><br><span class="line">        <span class="keyword">if</span> (entry.isExpired()) &#123;</span><br><span class="line">            request.addMarker(<span class="string">"cache-hit-expired"</span>);</span><br><span class="line">            request.setCacheEntry(entry);</span><br><span class="line">            <span class="keyword">if</span> (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">                mNetworkQueue.put(request);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在缓存中找到了这个请求，且没有过期，把 服务端返回的数据解析后取出，传回。</span></span><br><span class="line">       </span><br><span class="line">        request.addMarker(<span class="string">"cache-hit"</span>);</span><br><span class="line">        Response&lt;?&gt; response =</span><br><span class="line">                request.parseNetworkResponse(</span><br><span class="line">                        <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</span><br><span class="line">        request.addMarker(<span class="string">"cache-hit-parsed"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</span><br><span class="line">            <span class="comment">// 直接发送</span></span><br><span class="line">            mDelivery.postResponse(request, response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发送缓存的同时 也把request加入到网络请求线程，刷新数据</span></span><br><span class="line">            request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</span><br><span class="line">            request.setCacheEntry(entry);</span><br><span class="line">            <span class="comment">// Mark the response as intermediate.</span></span><br><span class="line">            response.intermediate = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123;</span><br><span class="line">                <span class="comment">// Post the intermediate response back to the user and have</span></span><br><span class="line">                <span class="comment">// the delivery then forward the request along to the network.</span></span><br><span class="line">                mDelivery.postResponse(</span><br><span class="line">                        request,</span><br><span class="line">                        response,</span><br><span class="line">                        <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    mNetworkQueue.put(request);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                    <span class="comment">// Restore the interrupted status</span></span><br><span class="line">                                    Thread.currentThread().interrupt();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// request has been added to list of waiting requests</span></span><br><span class="line">                <span class="comment">// to receive the network response from the first request once it returns.</span></span><br><span class="line">                mDelivery.postResponse(request, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="NetworkDispatcher"><a href="#NetworkDispatcher" class="headerlink" title="NetworkDispatcher"></a>NetworkDispatcher</h4><p>看完了 缓存队列的执行方式， 再看下网络请求线程的执行，跟上面的方法方式类似，我们直奔processRequest看它是如何实现的。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(Request&lt;?&gt; request)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">long</span> startTimeMs = SystemClock.elapsedRealtime();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           request.addMarker(<span class="string">"network-queue-take"</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 是否取消，取消的话就结束</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">               request.finish(<span class="string">"network-discard-cancelled"</span>);</span><br><span class="line">               request.notifyListenerResponseNotUsable();</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           addTrafficStatsTag(request);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 进行网络请求， performRequest 这个方法中是具体的网络请求的内容</span></span><br><span class="line">           NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class="line">           request.addMarker(<span class="string">"network-http-complete"</span>);</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line">           <span class="comment">// 如果返回304 同时已经回传过了返回值，就不再回传内容了，结束</span></span><br><span class="line">           <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class="line">               request.finish(<span class="string">"not-modified"</span>);</span><br><span class="line">               request.notifyListenerResponseNotUsable();</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 在工作线程中解析返回内容</span></span><br><span class="line">           Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class="line">           request.addMarker(<span class="string">"network-parse-complete"</span>);</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line">            <span class="comment">//如果需要缓存， 就把内容放到缓存中</span></span><br><span class="line">            <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">               mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">               request.addMarker(<span class="string">"network-cache-written"</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 把解析出的内容回传。</span></span><br><span class="line">           request.markDelivered();</span><br><span class="line">           mDelivery.postResponse(request, response);</span><br><span class="line">           request.notifyListenerResponseReceived(response);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</span><br><span class="line">           volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</span><br><span class="line">           parseAndDeliverNetworkError(request, volleyError);</span><br><span class="line">           request.notifyListenerResponseNotUsable();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</span><br><span class="line">           VolleyError volleyError = <span class="keyword">new</span> VolleyError(e);</span><br><span class="line">           volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs);</span><br><span class="line">           mDelivery.postError(request, volleyError);</span><br><span class="line">           request.notifyListenerResponseNotUsable();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>具体执行网络请求的是 BasicNetwork 的 performRequest 方法</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123;</span><br><span class="line">    long requestStart = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        HttpResponse httpResponse = <span class="literal">null</span>;</span><br><span class="line">        byte[] responseContents = <span class="literal">null</span>;</span><br><span class="line">        List&lt;Header&gt; responseHeaders = Collections.emptyList();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 把所有的header 信息拿到</span></span><br><span class="line">            Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; additionalRequestHeaders =</span><br><span class="line">                    getCacheHeaders(request.getCacheEntry());</span><br><span class="line">            <span class="comment">// 具体的根据不同的情况，看Android SDK 版本号 是否小于9 来选择使用</span></span><br><span class="line">            <span class="comment">// httpClient 还是httpUrlconnection 进行创建网络链接</span></span><br><span class="line">            httpResponse = mBaseHttpStack.executeRequest(request, additionalRequestHeaders);</span><br><span class="line">            int statusCode = httpResponse.getStatusCode();</span><br><span class="line"></span><br><span class="line">            responseHeaders = httpResponse.getHeaders();</span><br><span class="line">            <span class="comment">// 处理304问题</span></span><br><span class="line">            <span class="keyword">if</span> (statusCode == HttpURLConnection.HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">                Entry entry = request.getCacheEntry();</span><br><span class="line">                <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">NetworkResponse</span>(</span><br><span class="line">                            HttpURLConnection.HTTP_NOT_MODIFIED,</span><br><span class="line">                            <span class="comment">/* data= */</span> <span class="literal">null</span>,</span><br><span class="line">                            <span class="comment">/* notModified= */</span> <span class="literal">true</span>,</span><br><span class="line">                            SystemClock.elapsedRealtime() - requestStart,</span><br><span class="line">                            responseHeaders);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Combine cached and response headers so the response will be complete.</span></span><br><span class="line">                List&lt;Header&gt; combinedHeaders = combineHeaders(responseHeaders, entry);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">NetworkResponse</span>(</span><br><span class="line">                        HttpURLConnection.HTTP_NOT_MODIFIED,</span><br><span class="line">                        entry.data,</span><br><span class="line">                        <span class="comment">/* notModified= */</span> <span class="literal">true</span>,</span><br><span class="line">                        SystemClock.elapsedRealtime() - requestStart,</span><br><span class="line">                        combinedHeaders);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理异常情况                </span></span><br><span class="line">            InputStream inputStream = httpResponse.getContent();</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                responseContents =</span><br><span class="line">                        inputStreamToBytes(inputStream, httpResponse.getContentLength());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Add 0 byte response as a way of honestly representing a</span></span><br><span class="line">                <span class="comment">// no-content request.</span></span><br><span class="line">                responseContents = <span class="keyword">new</span> <span class="type">byte</span>[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if the request is slow, log it.</span></span><br><span class="line">            long requestLifetime = SystemClock.elapsedRealtime() - requestStart;</span><br><span class="line">            logSlowRequests(requestLifetime, request, responseContents, statusCode);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IOException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最后new 了一个NetworkResponse 把返回的内容包装后返回前一个方法，继续处理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">NetworkResponse</span>(</span><br><span class="line">                    statusCode,</span><br><span class="line">                    responseContents,</span><br><span class="line">                    <span class="comment">/* notModified= */</span> <span class="literal">false</span>,</span><br><span class="line">                    SystemClock.elapsedRealtime() - requestStart,</span><br><span class="line">                    responseHeaders);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">         <span class="comment">//重试机制</span></span><br><span class="line">            attemptRetryOnException(<span class="string">"socket"</span>, request, <span class="keyword">new</span> <span class="type">TimeoutError</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Bad URL "</span> + request.getUrl(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            int statusCode;</span><br><span class="line">            <span class="keyword">if</span> (httpResponse != <span class="literal">null</span>) &#123;</span><br><span class="line">                statusCode = httpResponse.getStatusCode();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoConnectionError</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            VolleyLog.e(<span class="string">"Unexpected response code %d for %s"</span>, statusCode, request.getUrl());</span><br><span class="line">            NetworkResponse networkResponse;</span><br><span class="line">            <span class="keyword">if</span> (responseContents != <span class="literal">null</span>) &#123;</span><br><span class="line">                networkResponse =</span><br><span class="line">                        <span class="keyword">new</span> <span class="type">NetworkResponse</span>(</span><br><span class="line">                                statusCode,</span><br><span class="line">                                responseContents,</span><br><span class="line">                                <span class="comment">/* notModified= */</span> <span class="literal">false</span>,</span><br><span class="line">                                SystemClock.elapsedRealtime() - requestStart,</span><br><span class="line">                                responseHeaders);</span><br><span class="line">                <span class="keyword">if</span> (statusCode == HttpURLConnection.HTTP_UNAUTHORIZED</span><br><span class="line">                        || statusCode == HttpURLConnection.HTTP_FORBIDDEN) &#123;</span><br><span class="line">                   <span class="comment">//重试机制</span></span><br><span class="line">                    attemptRetryOnException(</span><br><span class="line">                            <span class="string">"auth"</span>, request, <span class="keyword">new</span> <span class="type">AuthFailureError</span>(networkResponse));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusCode &gt;= <span class="number">400</span> &amp;&amp; statusCode &lt;= <span class="number">499</span>) &#123;</span><br><span class="line">                    <span class="comment">// Don't retry other client errors.</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ClientError</span>(networkResponse);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusCode &gt;= <span class="number">500</span> &amp;&amp; statusCode &lt;= <span class="number">599</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (request.shouldRetryServerErrors()) &#123;</span><br><span class="line">                        attemptRetryOnException(</span><br><span class="line">                                <span class="string">"server"</span>, request, <span class="keyword">new</span> <span class="type">ServerError</span>(networkResponse));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ServerError</span>(networkResponse);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 3xx? No reason to retry.</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ServerError</span>(networkResponse);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//重试机制</span></span><br><span class="line">                attemptRetryOnException(<span class="string">"network"</span>, request, <span class="keyword">new</span> <span class="type">NetworkError</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HurlStack"><a href="#HurlStack" class="headerlink" title="HurlStack"></a>HurlStack</h4><p>我们可以再看下建立网络链接的部分，这个是httpUrlcinnection，</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> HttpResponse executeRequest(Request&lt;?&gt; request, Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; additionalHeaders)</span><br><span class="line">        <span class="keyword">throws</span> IOException, AuthFailureError &#123;</span><br><span class="line">    <span class="keyword">String</span> url = request.getUrl();</span><br><span class="line">    <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="built_in">map</span>.putAll(additionalHeaders);</span><br><span class="line">    <span class="comment">// Request.getHeaders() takes precedence over the given additional (cache) headers).</span></span><br><span class="line">    <span class="built_in">map</span>.putAll(request.getHeaders());</span><br><span class="line">    <span class="keyword">if</span> (mUrlRewriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">String</span> rewritten = mUrlRewriter.rewriteUrl(url);</span><br><span class="line">        <span class="keyword">if</span> (rewritten == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"URL blocked by rewriter: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        url = rewritten;</span><br><span class="line">    &#125;</span><br><span class="line">    URL parsedUrl = <span class="keyword">new</span> URL(url);</span><br><span class="line">    HttpURLConnection connection = openConnection(parsedUrl, request);</span><br><span class="line">    <span class="built_in">boolean</span> keepConnectionOpen = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">String</span> headerName : <span class="built_in">map</span>.keySet()) &#123;</span><br><span class="line">            connection.setRequestProperty(headerName, <span class="built_in">map</span>.<span class="built_in">get</span>(headerName));</span><br><span class="line">        &#125;</span><br><span class="line">        setConnectionParametersForRequest(connection, request);</span><br><span class="line">        <span class="comment">// Initialize HttpResponse with data from the HttpURLConnection.</span></span><br><span class="line">        <span class="built_in">int</span> responseCode = connection.getResponseCode();</span><br><span class="line">        <span class="keyword">if</span> (responseCode == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// -1 is returned by getResponseCode() if the response code could not be retrieved.</span></span><br><span class="line">            <span class="comment">// Signal to the caller that something was wrong with the connection.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Could not retrieve response code from HttpUrlConnection."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!hasResponseBody(request.getMethod(), responseCode)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HttpResponse(responseCode, convertHeaders(connection.getHeaderFields()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Need to keep the connection open until the stream is consumed by the caller. Wrap the</span></span><br><span class="line">        <span class="comment">// stream such that close() will disconnect the connection.</span></span><br><span class="line">        keepConnectionOpen = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpResponse(</span><br><span class="line">                responseCode,</span><br><span class="line">                convertHeaders(connection.getHeaderFields()),</span><br><span class="line">                connection.getContentLength(),</span><br><span class="line">                <span class="keyword">new</span> UrlConnectionInputStream(connection));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!keepConnectionOpen) &#123;</span><br><span class="line">            connection.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结上面这个方法就是 把所有的请求头信息发送出去，如果有请求体，把请求体也发送过去， 等待服务端相应，响应后把返回值回传到上一个方法中处理。</p><h4 id="volley-是如何实现线程切换的"><a href="#volley-是如何实现线程切换的" class="headerlink" title="volley 是如何实现线程切换的"></a>volley 是如何实现线程切换的</h4><ol><li>主线程上开启子线程执行网络请求在上面分析中能看到。 创建了1个缓存线程，4个网络请求线程，执行相应的网络请求。</li><li>子线程在处理完耗时操作，处理完数据，怎么发送到主线程的呢？</li></ol><h5 id="ExecutorDelivery"><a href="#ExecutorDelivery" class="headerlink" title="ExecutorDelivery"></a>ExecutorDelivery</h5><p>接下来看下我们上面多次看到的  mDelivery.postResponse(request, response); 是怎么处理的</p><p>先看下构造方法</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler <span class="keyword">handler</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注意这个 Handler 这是RequestQueue 构造方法中初始化的，传入的是 Looper.getMainLooper()， 它就是主线程的handler</span></span><br><span class="line">    <span class="comment">//创建了一个线程池，它的作用就是在线程中调用 handler，发送 runnable，通过这种形式使得 runnable 在 UI 线程中执行。</span></span><br><span class="line">        mResponsePoster =</span><br><span class="line">                <span class="keyword">new</span> Executor() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">handler</span>.post(command);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//看下具体方法</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">        request.markDelivered();</span><br><span class="line">        request.addMarker(<span class="string">"post-response"</span>);</span><br><span class="line">        mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，mResponsePoster.execute 是得里面的runnable能够在主线程中得到执行，</p><h5 id="ResponseDeliveryRunnable"><a href="#ResponseDeliveryRunnable" class="headerlink" title="ResponseDeliveryRunnable"></a>ResponseDeliveryRunnable</h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// If this request has canceled, finish it and don't deliver.</span></span><br><span class="line">    <span class="selector-tag">if</span> (mRequest.isCanceled()) &#123;</span><br><span class="line">        <span class="selector-tag">mRequest</span><span class="selector-class">.finish</span>(<span class="string">"canceled-at-delivery"</span>);</span><br><span class="line">        <span class="selector-tag">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deliver a normal response or error, depending.</span></span><br><span class="line">    <span class="selector-tag">if</span> (mResponse.isSuccess()) &#123;</span><br><span class="line">        <span class="selector-tag">mRequest</span><span class="selector-class">.deliverResponse</span>(mResponse.result);</span><br><span class="line">    &#125; <span class="selector-tag">else</span> &#123;</span><br><span class="line">        <span class="selector-tag">mRequest</span><span class="selector-class">.deliverError</span>(mResponse.error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is an intermediate response, add a marker, otherwise we're done</span></span><br><span class="line">    <span class="comment">// and the request can be finished.</span></span><br><span class="line">    <span class="selector-tag">if</span> (mResponse.intermediate) &#123;</span><br><span class="line">        <span class="selector-tag">mRequest</span><span class="selector-class">.addMarker</span>(<span class="string">"intermediate-response"</span>);</span><br><span class="line">    &#125; <span class="selector-tag">else</span> &#123;</span><br><span class="line">        <span class="selector-tag">mRequest</span><span class="selector-class">.finish</span>(<span class="string">"done"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送之后，都会调用 Runnable 的 run() ，这个已经可执行的 Runnable 已经切换到主线程了。</span></span><br><span class="line">    <span class="selector-tag">if</span> (mRunnable != null) &#123;</span><br><span class="line">        <span class="selector-tag">mRunnable</span><span class="selector-class">.run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用 request 的 finish 方法，表示该请求已经执行结束了，同时，如果 ResponseDeliveryRunnable 的构造方法中的第三个参数 runnable 不为空，立即执行该 runnable 的 run 方法。</p><p>再看这个Stringrequest中的</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">    Response.Listener&lt;String&gt; listener;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        listener = mListener;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        listener.onResponse(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主线程 通过接口回调，回调到发起请求的位置，进行相应的处理。</p><h3 id="volley-的优缺点"><a href="#volley-的优缺点" class="headerlink" title="volley 的优缺点"></a>volley 的优缺点</h3><p><strong>优点：</strong></p><ul><li>特别适合数据量小，通信频繁的网络操作</li><li>轻量，jar包相对较小</li><li>扩展性强。Volley 中大多是基于接口的设计，可配置性强。</li><li>一定程度符合 Http 规范，包括返回 ResponseCode(2xx、3xx、4xx、5xx）的处理，请求头的处理，缓存机制的支持等。并支持重试及优先级定义。</li><li>默认 Android2.3 及以上基于 HttpURLConnection，2.3 以下基于 HttpClient 实现，</li><li>提供简便的图片加载工具。</li><li>网络请求线程NetworkDispatcher默认开启了4个，可以优化，通过手机CPU数量</li></ul><p><strong>缺点：</strong></p><ul><li>在BasicNetwork中判断了statusCode(statusCode &lt; 200 || statusCode &gt; 299)，如何符合条件直接抛出IOException()，不够合理。</li><li>图片加载性能一般</li><li>导致401等其他状态抛出IOException </li><li>对大文件下载 Volley的表现非常糟糕</li><li>使用的是httpclient，HttpURLConnection。不过在android 6.0不支持httpclient了，如果想支持得添加org.apache.http.legacy.jar</li></ul><h4 id="为什么volley-不适合下载上传大文件？为什么适合数据量小的频率高的请求？"><a href="#为什么volley-不适合下载上传大文件？为什么适合数据量小的频率高的请求？" class="headerlink" title="为什么volley 不适合下载上传大文件？为什么适合数据量小的频率高的请求？"></a>为什么volley 不适合下载上传大文件？为什么适合数据量小的频率高的请求？</h4><ol><li>Volley的网络请求线程池默认大小为4。意味着可以并发进行4个请求，大于4个，会排在队列中。</li><li>Volley将整个response加载到内存并进行操作（可以是解析等操作）大文件可能会引起OOM</li></ol><h3 id="volley-的扩展"><a href="#volley-的扩展" class="headerlink" title="volley 的扩展"></a>volley 的扩展</h3><p>有时候我们整个项目在使用的volley 如果要替换成okhttp 的成本就比较高了， 那能不能方便简单的时候okhttp 的优秀的功能呢， 答案当然是可以的。</p><p>还记得这个吗？ 最开始分析源码时，</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="keyword">new</span><span class="type">RequestQueue</span>(Context context, BaseHttpStack stack) &#123;</span><br><span class="line">    BasicNetwork network;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (stack == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">            network = <span class="keyword">new</span> <span class="type">BasicNetwork</span>(<span class="keyword">new</span> <span class="type">HurlStack</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Prior to Gingerbread, HttpUrlConnection was unreliable.</span></span><br><span class="line">            <span class="comment">// See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span></span><br><span class="line">            <span class="comment">// At some point in the future we'll move our minSdkVersion past Froyo and can</span></span><br><span class="line">            <span class="comment">// delete this fallback (along with all Apache HTTP code).</span></span><br><span class="line">            <span class="keyword">String</span> userAgent = <span class="string">"volley/0"</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">String</span> packageName = context.getPackageName();</span><br><span class="line">                PackageInfo info =</span><br><span class="line">                        context.getPackageManager().getPackageInfo(packageName, <span class="comment">/* flags= */</span> <span class="number">0</span>);</span><br><span class="line">                userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            network =</span><br><span class="line">                    <span class="keyword">new</span> <span class="type">BasicNetwork</span>(</span><br><span class="line">                            <span class="keyword">new</span> <span class="type">HttpClientStack</span>(AndroidHttpClient.<span class="keyword">new</span><span class="type">Instance</span>(userAgent)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        network = <span class="keyword">new</span> <span class="type">BasicNetwork</span>(stack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span><span class="type">RequestQueue</span>(context, network);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们传stack 进来，这个 stack 就是null 了，所以，我们只需要实现这个HttpStack 然后传进来就行了。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public class OkHttpStack implements HttpStack &#123;</span><br><span class="line">    private final OkHttpClient mClient;</span><br><span class="line">//提供一个构造函数，传入OkHttpClient 对象</span><br><span class="line">    public OkHttpStack(OkHttpClient client) &#123;</span><br><span class="line">        this.mClient = client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static HttpEntity entityFromOkHttpResponse(Response response) throws IOException &#123;</span><br><span class="line">        BasicHttpEntity entity = new BasicHttpEntity();</span><br><span class="line">        ResponseBody body = response.body();</span><br><span class="line"></span><br><span class="line">        <span class="attribute">entity.setContent(body.byteStream());</span></span><br><span class="line">        entity.setContentLength(body.contentLength());</span><br><span class="line">        <span class="attribute">entity.setContentEncoding(response.header("Content-Encoding"));</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line">        if (body.contentType() != null) &#123;</span><br><span class="line">            <span class="attribute">entity.setContentType(body.contentType().type());</span></span><br><span class="line">        &#125;</span><br><span class="line">        return entity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//请求方法和请求体</span><br><span class="line">    @SuppressWarnings("deprecation")</span><br><span class="line">    private static void setConnectionParametersForRequest</span><br><span class="line">            (okhttp3.Request.Builder builder, Request&lt;?&gt; request)</span><br><span class="line">            throws IOException, AuthFailureError &#123;</span><br><span class="line">        switch (request.getMethod()) &#123;</span><br><span class="line">            case Request.Method.DEPRECATED_GET_OR_POST:</span><br><span class="line">                byte[] postBody = request.getPostBody();</span><br><span class="line">                if (postBody != null) &#123;</span><br><span class="line">                    <span class="attribute">builder.post(RequestBody.create</span></span><br><span class="line">                            (MediaType.parse(request.getPostBodyContentType()), postBody));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="attribute">break;</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line">            case Request.Method.GET:</span><br><span class="line">                <span class="attribute">builder.get();</span></span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case Request.Method.DELETE:</span><br><span class="line">                <span class="attribute">builder.delete();</span></span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case Request.Method.POST:</span><br><span class="line">                <span class="attribute">builder.post(createRequestBody(request));</span></span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case Request.Method.PUT:</span><br><span class="line">                <span class="attribute">builder.put(createRequestBody(request));</span></span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case Request.Method.HEAD:</span><br><span class="line">                <span class="attribute">builder.head();</span></span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case Request.Method.OPTIONS:</span><br><span class="line">                builder.method("OPTIONS", null);</span><br><span class="line">                <span class="attribute">break;</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line">            case Request.Method.TRACE:</span><br><span class="line">                builder.method("TRACE", null);</span><br><span class="line">                <span class="attribute">break;</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line">            case Request.Method.PATCH:</span><br><span class="line">                <span class="attribute">builder.patch(createRequestBody(request));</span></span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">default:</span></span><br><span class="line">                throw new IllegalStateException("Unknown method type.");</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static RequestBody createRequestBody(Request request) throws AuthFailureError &#123;</span><br><span class="line">        final byte[] body = request.getBody();</span><br><span class="line">        if (body == null) return null;</span><br><span class="line"></span><br><span class="line">        return RequestBody.create(MediaType.parse(request.getBodyContentType()), body);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static ProtocolVersion parseProtocol(final Protocol protocol) &#123;</span><br><span class="line">        switch (protocol) &#123;</span><br><span class="line">            case HTTP_1_0:</span><br><span class="line">                return new ProtocolVersion("HTTP", 1, 0);</span><br><span class="line">            case HTTP_1_1:</span><br><span class="line">                return new ProtocolVersion("HTTP", 1, 1);</span><br><span class="line">            case SPDY_3:</span><br><span class="line">                return new ProtocolVersion("SPDY", 3, 1);</span><br><span class="line">            case HTTP_2:</span><br><span class="line">                return new ProtocolVersion("HTTP", 2, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw new IllegalAccessError("Unkwown protocol");</span><br><span class="line">    &#125;</span><br><span class="line">//performRequest方法,首先我们设置一下超时时间</span><br><span class="line">    @Override</span><br><span class="line">    public HttpResponse performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span><br><span class="line">            throws IOException, AuthFailureError &#123;</span><br><span class="line">        int timeoutMs = request.getTimeoutMs();</span><br><span class="line">        OkHttpClient client = mClient.newBuilder()</span><br><span class="line">                .readTimeout(timeoutMs, TimeUnit.MILLISECONDS)</span><br><span class="line">                .connectTimeout(timeoutMs, TimeUnit.MILLISECONDS)</span><br><span class="line">                .writeTimeout(timeoutMs, TimeUnit.MILLISECONDS)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        okhttp3.Request.Builder okHttpRequestBuilder = new okhttp3.Request.Builder();</span><br><span class="line">        //设置请求头，请求头的来源有两个</span><br><span class="line">        Map&lt;String, String&gt; headers = request.getHeaders();</span><br><span class="line">        for (final String name : headers.keySet()) &#123;</span><br><span class="line">            okHttpRequestBuilder.addHeader(name, headers.get(name));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (final String name : additionalHeaders.keySet()) &#123;</span><br><span class="line">            okHttpRequestBuilder.addHeader(name, additionalHeaders.get(name));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setConnectionParametersForRequest(okHttpRequestBuilder, request);</span><br><span class="line"></span><br><span class="line">        okhttp3.Request okhttp3Request = okHttpRequestBuilder.url(request.getUrl()).build();</span><br><span class="line">        //开始请求</span><br><span class="line">        Response okHttpResponse = client.newCall(okhttp3Request).execute();</span><br><span class="line"></span><br><span class="line">        StatusLine responseStatus = new BasicStatusLine</span><br><span class="line">                (</span><br><span class="line">                        <span class="attribute">parseProtocol(okHttpResponse.protocol()),</span></span><br><span class="line">                        okHttpResponse.code(),</span><br><span class="line">                        <span class="attribute">okHttpResponse.message()</span></span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        BasicHttpResponse response = new BasicHttpResponse(responseStatus);</span><br><span class="line">        <span class="attribute">response.setEntity(entityFromOkHttpResponse(okHttpResponse));</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line">        Headers responseHeaders = okHttpResponse.headers();</span><br><span class="line">        for (int i = 0, len = responseHeaders.size(); i &lt; len; i++) &#123;</span><br><span class="line">            final String name = responseHeaders.name(i), value = responseHeaders.value(i);</span><br><span class="line">            if (name != null) &#123;</span><br><span class="line">                response.addHeader(new BasicHeader(name, value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">//最后返回HttpResponse对象</span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总体来看，volley 源码还是比较简单的，结构清晰，代码量少，对于想读源码的同学还是一个比较不错的选择。有兴趣的可以尝试下。 也希望看这篇文章的同学能从本文中受益，也欢迎与我交流学习。</p><p>下一篇是分析 okHttp 的源码，敬请期待。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Volley-源码解析&quot;&gt;&lt;a href=&quot;#Volley-源码解析&quot; class=&quot;headerlink&quot; title=&quot;Volley 源码解析&quot;&gt;&lt;/a&gt;Volley 源码解析&lt;/h2&gt;&lt;h3 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="源码" scheme="http://youngerdev.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="网络请求" scheme="http://youngerdev.com/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    
      <category term="Android网络" scheme="http://youngerdev.com/tags/Android%E7%BD%91%E7%BB%9C/"/>
    
      <category term="volley" scheme="http://youngerdev.com/tags/volley/"/>
    
      <category term="volley扩展" scheme="http://youngerdev.com/tags/volley%E6%89%A9%E5%B1%95/"/>
    
      <category term="volley优缺点" scheme="http://youngerdev.com/tags/volley%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>网络基础知识</title>
    <link href="http://youngerdev.com/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html"/>
    <id>http://youngerdev.com/网络基础知识.html</id>
    <published>2019-10-03T07:45:34.000Z</published>
    <updated>2019-10-08T00:33:18.705Z</updated>
    
    <content type="html"><![CDATA[<p>计划写两篇关于 解析 Volley源码 和 Okhttp源码的文章 先了解下基础的网络知识。</p><p>目前存在的两种网络分层模型：OSI模型和TCP/IP模型。OSI模型一共分为七层，TCP/IP模型和OSI模型类似，但是只分为四层。</p><h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><ul><li>应用层(Application)</li><li>表示层(Presentation)</li><li>会话层(Session)</li><li>传输层(Transport)</li><li>网络层(Network)</li><li>数据链路层(Data Link)</li><li>物理层(Physical)</li></ul><h3 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h3><p>TCP/IP模型分为四层：应用层（Application）、传输层（Host-to-Host Transport）、互联网层(Internet)、网络接口层(Network Interface)。</p><p>在TCP/IP模型中并不包含物理层。另外，两个重要的协议ARP（Address Resolution Protocol，地址解析协议）和RARP（Reverse Address Resolution Protocol，反向地址转换协议），在OSI模型中一般被认为是在位于第二层数据链路层和第三层网络层之间，而在TCP/IP模型中则位于网络接口层。</p><ul><li><p>应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等</p></li><li><p>传输层：TCP，UDP</p></li><li><p>网络层：IP，ICMP，OSPF，EIGRP，IGMP</p></li><li><p>数据链路层：SLIP，CSLIP，PPP，MTU</p></li></ul><p>每一抽象层建立在低一层提供的服务上，并且为高一层提供服务</p><h3 id="TCP-三次握手与四次挥手"><a href="#TCP-三次握手与四次挥手" class="headerlink" title="TCP 三次握手与四次挥手"></a>TCP 三次握手与四次挥手</h3><h4 id="TCP-Transmission-Control-Protocol-传输控制协议"><a href="#TCP-Transmission-Control-Protocol-传输控制协议" class="headerlink" title="TCP (Transmission Control Protocol)　传输控制协议"></a>TCP (Transmission Control Protocol)　传输控制协议</h4><ul><li>TCP 提供一种面向连接的、可靠的字节流服务</li><li>在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP</li><li>TCP 使用校验,确认和重传机制来保证可靠传输</li><li>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</li><li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li></ul><p>注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。</p><p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。</p><ul><li>第一次握手(SYN=1, seq=x):</li></ul><p>客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。</p><p>发送完毕后，客户端进入 SYN_SEND 状态。</p><ul><li>第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):</li></ul><p>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。</p><ul><li>第三次握手(ACK=1，ACKnum=y+1)</li></ul><p>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1</p><p>发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。</p><ul><li>第一次挥手(FIN=1，seq=x)</li></ul><p>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p><p>发送完毕后，客户端进入 FIN_WAIT_1 状态。</p><ul><li>第二次挥手(ACK=1，ACKnum=x+1)</li></ul><p>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p><p>发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。</p><ul><li>第三次挥手(FIN=1，seq=y)</li></ul><p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。</p><p>发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。</p><ul><li>第四次挥手(ACK=1，ACKnum=y+1)</li></ul><p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。</p><p>服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</p><p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。</p><h3 id="UDP-（User-Datagram-Protoco）用户数据报协议"><a href="#UDP-（User-Datagram-Protoco）用户数据报协议" class="headerlink" title="UDP （User Datagram Protoco）用户数据报协议"></a>UDP （User Datagram Protoco）用户数据报协议</h3><p>UDP 是一个简单的传输层协议。和 TCP 相比，UDP 有下面几个显著特性：</p><ul><li>UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次</li><li>UDP 数据报是有长度的。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界。</li><li>UDP 是无连接的。UDP 客户和服务器之前不必存在长期的关系。UDP 发送数据报之前也不需要经过握手创建连接的过程。</li><li>UDP 支持多播和广播。</li></ul><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><p>socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种”打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</p><h3 id="Http-协议"><a href="#Http-协议" class="headerlink" title="Http 协议"></a>Http 协议</h3><ul><li>HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80</li><li>HTTP 是无连接无状态的</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计划写两篇关于 解析 Volley源码 和 Okhttp源码的文章 先了解下基础的网络知识。&lt;/p&gt;
&lt;p&gt;目前存在的两种网络分层模型：OSI模型和TCP/IP模型。OSI模型一共分为七层，TCP/IP模型和OSI模型类似，但是只分为四层。&lt;/p&gt;
&lt;h3 id=&quot;OSI模
      
    
    </summary>
    
    
      <category term="网络" scheme="http://youngerdev.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="tcp" scheme="http://youngerdev.com/tags/tcp/"/>
    
      <category term="ip" scheme="http://youngerdev.com/tags/ip/"/>
    
      <category term="http" scheme="http://youngerdev.com/tags/http/"/>
    
      <category term="socket" scheme="http://youngerdev.com/tags/socket/"/>
    
      <category term="三次握手" scheme="http://youngerdev.com/tags/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    
      <category term="四次挥手" scheme="http://youngerdev.com/tags/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>ListView 优化及相关问题总结</title>
    <link href="http://youngerdev.com/ListView-%E4%BC%98%E5%8C%96%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html"/>
    <id>http://youngerdev.com/ListView-优化及相关问题总结.html</id>
    <published>2019-08-11T02:56:37.000Z</published>
    <updated>2019-08-11T08:57:11.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ListView-优化"><a href="#ListView-优化" class="headerlink" title="ListView 优化"></a>ListView 优化</h2><p>最近在做项目过程中频繁使用列表，今天抽空总结下过程中遇到的问题，下面会有具体对应的解决办法；</p><ul><li>1.listView 外套一层ScrollView 的问题，就是listView 只显示一行或者两行， 我发现这个问题在 <strong>RecycleView 上也存在</strong>， 在RecycleView外套一层 ScrollView也会出现只显示一行的问题，滑动只能在 一行的高度内滑动。这问题下面有具体解决方案，说下我是怎么解决的吧，因为我要实现的是9宫格的图片展示，本来是用的RecycleView 来实现的，出现了这个问题，我就尝试把recyclerView 换成了GridView 了，因为GridView 本身就支持多行展示，发现就没有这个问题了，套了ScrollView 也正常展示；</li><li>2.也是listView 在嵌套ScrollView 中的问题，在某款三星手机上，这个手机的虚拟按键，可以锁定和解锁定， 发现在切换锁定和解锁定中，会导致原来的多行的图片变成单行， 在别的手机上就没有这个问题， 这个奇怪的现象，最终还是以GridView 替换掉listView 解决的。</li><li>3.listView 添加 headerView的问题， 需要注意的是 添加进去的 HeaderView 就占据了第0位，所以在使用的 onItemClick 的时候，需要-1， addfooterView的时候可以用 view.getFooterViewsCount() 是否等于0来判断，避免多次添加。</li><li>4.由于listView 会复用viewHolder ，所以我们在getView 中 显示隐藏的设置一定要配套使用，if里有显示，在else 中就要 隐藏。</li></ul><h3 id="优化步骤："><a href="#优化步骤：" class="headerlink" title="优化步骤："></a>优化步骤：</h3><h4 id="使用-RecycleView-代替listview"><a href="#使用-RecycleView-代替listview" class="headerlink" title="使用 RecycleView 代替listview"></a>使用 RecycleView 代替listview</h4><ul><li>1.重用ConvertView;</li><li>2.使用View Holder模式；</li><li>3.使用异步线程加载图片（一般都是直接使用图片库加载，如Glide, Picasso）；<h5 id="建议"><a href="#建议" class="headerlink" title="建议:"></a>建议:</h5></li><li>1.在adapter的getView方法中尽可能的减少逻辑判断，特别是耗时的判断；</li><li>2.避免GC</li><li>3.在快速滑动时不要加载图片；</li><li>4.将ListView的scrollingCache和animateCache这两个属性设置为false（默认是true）;</li><li>5.尽可能减少List Item的Layout层次（如可以使用RelativeLayout替换LinearLayout，或使用自定的View代替组合嵌套使用的Layout）</li></ul><h4 id="ListView-嵌套-ScrollView"><a href="#ListView-嵌套-ScrollView" class="headerlink" title="ListView  嵌套 ScrollView"></a>ListView  嵌套 ScrollView</h4><p>Listview不能显示正常的条目，只显示一条或二条</p><p>这是因为：由于listView在scrollView中无法正确计算它的大小, 故只显示一行。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h4><h5 id="1-方法一：重写ListView-覆盖onMeasure-方法"><a href="#1-方法一：重写ListView-覆盖onMeasure-方法" class="headerlink" title="1. 方法一：重写ListView, 覆盖onMeasure()方法"></a>1. 方法一：重写ListView, 覆盖onMeasure()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">WrapperListView.java:</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperListView</span> <span class="keyword">extends</span> <span class="title">ListView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrapperListView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrapperListView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrapperListView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrapperListView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写该方法，达到使ListView适应ScrollView的效果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; <span class="number">2</span>, MeasureSpec.AT_MOST);</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, expandSpec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-方法二：动态设置listview的高度，不需要重写ListView"><a href="#2-方法二：动态设置listview的高度，不需要重写ListView" class="headerlink" title="2.方法二：动态设置listview的高度，不需要重写ListView"></a>2.方法二：动态设置listview的高度，不需要重写ListView</h5><p>只需要在setAdapter之后调用如下方法即可：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setListViewHeightBasedOnChildren</span>(<span class="params">ListView listView</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取ListView对应的Adapter</span></span><br><span class="line">        ListAdapter listAdapter = listView.getAdapter();</span><br><span class="line">        <span class="keyword">if</span> (listAdapter == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> totalHeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = listAdapter.getCount(); i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// listAdapter.getCount()返回数据项的数目</span></span><br><span class="line">            View listItem = listAdapter.getView(i, <span class="literal">null</span>, listView);</span><br><span class="line">            <span class="comment">// 计算子项View 的宽高</span></span><br><span class="line">            listItem.measure(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 统计所有子项的总高度</span></span><br><span class="line">            totalHeight += listItem.getMeasuredHeight();</span><br><span class="line">        &#125;</span><br><span class="line">        ViewGroup.LayoutParams <span class="keyword">params</span> = listView.getLayoutParams();</span><br><span class="line">        <span class="keyword">params</span>.height = totalHeight + (listView.getDividerHeight() * (listAdapter.getCount() - <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// listView.getDividerHeight()获取子项间分隔符占用的高度</span></span><br><span class="line">        <span class="comment">// params.height最后得到整个ListView完整显示需要的高度</span></span><br><span class="line">        listView.setLayoutParams(<span class="keyword">params</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这时最好给ListView之外嵌套一层LinearLayout，不然有时候这种方法会失效</p><h5 id="3-方法三：在xml文件中，直接将Listview的高度写死"><a href="#3-方法三：在xml文件中，直接将Listview的高度写死" class="headerlink" title="3.方法三：在xml文件中，直接将Listview的高度写死"></a>3.方法三：在xml文件中，直接将Listview的高度写死</h5><p>可以确定的是：这种方式可以改变ListView的高度，但是，还有一个严重的问题就是listview的数据是可变动的，除非你能正确的写出listview的高度，否则这种方式就是个鸡肋。</p><h5 id="4-addHeadView"><a href="#4-addHeadView" class="headerlink" title="4. addHeadView()"></a>4. addHeadView()</h5><p>如果只有数据 layout 完全没有必要嵌套 ScrollView 的.之说以需要嵌套,很多是在listView 头部或者底部多了一部分Layout ,这个时候可以尝试 listView 的 addHeadView() 尝试解决</p><h3 id="在一次显示ListView的界面时，getView会被执行几次？"><a href="#在一次显示ListView的界面时，getView会被执行几次？" class="headerlink" title="在一次显示ListView的界面时，getView会被执行几次？"></a>在一次显示ListView的界面时，getView会被执行几次？</h3><p>比如有5组数据要填充到listView。listView会先调用onMeasure，此时会调用5次getView。然后才调用onLayout，此时又会调用5次getView，这样就重复了。所以导致多次调用getView方法</p><p>的确调用了三遍</p><p>解决办法:</p><p>ListView 的高度 从 wrap_content 改成 match_patent 或者一个固定值,就能减少getview 调用次数 </p><p>或者重写 listView 的onMasure onLayout 方法  赋值 一个变量 检测 是测量还是layout  测量时不加载自己写的那段逻辑</p><h4 id="listview失去焦点怎么处理？"><a href="#listview失去焦点怎么处理？" class="headerlink" title="listview失去焦点怎么处理？"></a>listview失去焦点怎么处理？</h4><p>在listview子布局里面写，可以解决焦点失去的问题<br>android:descendantFocusability=”blocksDescendants”</p><h4 id="ListView-优化-1"><a href="#ListView-优化-1" class="headerlink" title="ListView 优化"></a>ListView 优化</h4><ul><li><p>1.首先，虽然大家都知道，还是提一下，利用好 convertView 来重用 View，切忌每次 getView() 都新建。ListView 的核心原理就是重用 View。ListView 中有一个回收器，Item 滑出界面的时候 View 会回收到这里，需要显示新的 Item 的时候，就尽量重用回收器里面的 View。</p></li><li><p>2.利用好 View Type，例如你的 ListView 中有几个类型的 Item，需要给每个类型创建不同的 View，这样有利于 ListView 的回收，当然类型不能太多</p></li><li>3.尽量让 ItemView 的 Layout 层次结构简单，这是所有 Layout 都必须遵循的</li><li>4.善用自定义 View，自定义 View 可以有效的减小 Layout 的层级，而且对绘制过程可以很好的控制；</li><li>5.尽量能保证 Adapter 的 hasStableIds() 返回 true，这样在 notifyDataSetChanged() 的时候，如果 id 不变，ListView 将不会重新绘制这个 View，达到优化的目的；</li><li>6.每个 Item 不能太高，特别是不要超过屏幕的高度，可以参考 Facebook 的优化方法，把特别复杂的 Item 分解成若干小的 Item，</li><li>7.为了保证 ListView 滑动的流畅性，getView() 中要做尽量少的事情，不要有耗时的操作。特别是滑动的时候不要加载图片，停下来再加载，这个库可以帮助你 Glide：<a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">https://github.com/bumptech/glide</a></li><li>8.使用 RecycleView 代替。 ListView 每次更新数据都要 notifyDataSetChanged()，有些太暴力了。RecycleView 在性能和可定制性上都有很大的改善，推荐使用。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ListView-优化&quot;&gt;&lt;a href=&quot;#ListView-优化&quot; class=&quot;headerlink&quot; title=&quot;ListView 优化&quot;&gt;&lt;/a&gt;ListView 优化&lt;/h2&gt;&lt;p&gt;最近在做项目过程中频繁使用列表，今天抽空总结下过程中遇到的问题，下面
      
    
    </summary>
    
    
      <category term="Android listView" scheme="http://youngerdev.com/tags/Android-listView/"/>
    
      <category term="ListView优化" scheme="http://youngerdev.com/tags/ListView%E4%BC%98%E5%8C%96/"/>
    
      <category term="列表优化" scheme="http://youngerdev.com/tags/%E5%88%97%E8%A1%A8%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>网站优化</title>
    <link href="http://youngerdev.com/%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96.html"/>
    <id>http://youngerdev.com/网站优化.html</id>
    <published>2019-05-30T00:11:39.000Z</published>
    <updated>2019-05-30T00:24:17.130Z</updated>
    
    <content type="html"><![CDATA[<p>网站在今年2月份就创建了，但是一直没有怎么优化。最近几天，简单美化了一下<br>现在就把相关的优化网站列一下，希望对读者有点帮助。</p><p><a href="https://www.lixint.me/hexo-blog.html" target="_blank" rel="noopener">Github Pages + Hexo 博客搭建，Next主题个性化修改</a> 有很多链接，包括从创建到优化，还有视频教程。</p><p><a href="https://www.lixint.me/hexo-theme-diy.html" target="_blank" rel="noopener">Hexo博客主题安装及Next主题个性化修改</a> 不得不说，这个对我帮助很大。</p><p><a href="https://yashuning.github.io/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">hexo - Next 主题添加评论功能</a> 这个是给我们的网站加评论的， 我选择 <strong>Valine</strong> 评论系统 ，我希望可以匿名评论。</p><p>后续还有 seo 优化还没有做，这个会继续更新的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;网站在今年2月份就创建了，但是一直没有怎么优化。最近几天，简单美化了一下&lt;br&gt;现在就把相关的优化网站列一下，希望对读者有点帮助。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.lixint.me/hexo-blog.html&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://youngerdev.com/tags/hexo/"/>
    
      <category term="页面优化" scheme="http://youngerdev.com/tags/%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android中公共代码仓库与私服的使用</title>
    <link href="http://youngerdev.com/Android%E4%B8%AD%E5%85%AC%E5%85%B1%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93%E4%B8%8E%E7%A7%81%E6%9C%8D%E7%9A%84%E4%BD%BF%E7%94%A8.html"/>
    <id>http://youngerdev.com/Android中公共代码仓库与私服的使用.html</id>
    <published>2019-05-27T15:18:43.000Z</published>
    <updated>2019-05-29T15:34:30.358Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章 <a href="https://youngerdev.com/Android中SO文件使用.html">从ARM暂停与华为合作谈起 Android中SO兼容的那些事</a> 中提到了我们是用自己私服上的weex sdk 出的问题继而解决的问题,今天就来介绍下我们的私服, 并手把手教会你怎么创建并使用私服.</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>随着公司业务发展，项目越来越大，项目有好几个，项目虽然具体业务不同，但是其中也有很多相同的功能， 比如都有 weex 需求，网络请求、 图片处理、视频处理等等共同的需求，如果每个项目都重新写一遍，实现一遍，势必影响进度，重复造轮子的问题，项目进展缓慢，所以 就需要一种方式来避免这种重复劳动，彻底解决这种问题。</p><p><strong>解决办法</strong> : 使用组件化的思想， 把公共的组件抽离出来，和主项目的关系是依赖主项目的关系。module 是以 library的形式存在于整个project 中，依赖于主工程。在需要使用的时候，引入即可。<br>类似我们使用 recyclerview butterknife 之类的这些的功能， 这些内容有的是 Android官方提供的支持，有的是国内外优秀开发者开源出来的控件，我们可以很方便的集成到项目中。如下图：</p><p><a href="https://i.loli.net/2019/05/27/5cebf995ea1db50700.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cebf995ea1db50700.png" alt="仓库1.png"></a></p><h3 id="知名仓库介绍"><a href="#知名仓库介绍" class="headerlink" title="知名仓库介绍"></a>知名仓库介绍</h3><p>目前有 jcenter（） ，mavenCentral（）， google（） 等等仓库中心，这些仓库是用来保存代码的，组织或者个人开发者 开源出很多优秀的代码，工具，控件，上传到这些仓库中，我们可以通过 在 gradle 中配置相应的仓库地址 ，就可以方便使用相应的代码，</p><p>而内部使用的组件，不适合开源的可以自己搭建 私有仓库，内网使用，<br>还有一些需要借助代理访问，国内访问起来特别慢或者无法访问的内容，也可以上传到我们的私服上，能够很好地提高效率，减少同步等待时间<br>类似下图 我们在其中一个项目中使用的 仓库地址：</p><p><a href="https://i.loli.net/2019/05/27/5cebf995da23532578.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cebf995da23532578.png" alt="仓库2.png"></a></p><p>我们通过在 gradle 中配置相应的依赖，项目在 build 完成后就会将相应的 依赖工程代码 下载到 项目中， 可以在project 模式下 查看 External Libraries 看到实际下载下来的代码。</p><p><a href="https://i.loli.net/2019/05/27/5cebf9966676a13796.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cebf9966676a13796.png" alt="仓库3.png"></a></p><p>下面分别介绍下 这几个仓库，和私有仓库的搭建</p><h4 id="jcenter"><a href="#jcenter" class="headerlink" title="jcenter"></a>jcenter</h4><p>网页地址  <a href="http://jcenter.bintray.com/" target="_blank" rel="noopener">http://jcenter.bintray.com/</a></p><h4 id="mavenCentral"><a href="#mavenCentral" class="headerlink" title="mavenCentral"></a>mavenCentral</h4><p>网页地址<a href="http://central.maven.org/maven2/" target="_blank" rel="noopener">http://central.maven.org/maven2/</a></p><h4 id="google"><a href="#google" class="headerlink" title="google"></a>google</h4><p>网页地址  <a href="https://dl.google.com/dl/android/maven2/" target="_blank" rel="noopener">https://dl.google.com/dl/android/maven2/</a></p><h4 id="其他仓库"><a href="#其他仓库" class="headerlink" title="其他仓库"></a>其他仓库</h4><p>以阿里云为例<br>网页地址 <a href="http://maven.aliyun.com/nexus/content/repositories/jcenter/" target="_blank" rel="noopener">http://maven.aliyun.com/nexus/content/repositories/jcenter/</a></p><p>上图中已经展示了 在项目中的配置这些仓库的方式。</p><h3 id="这些仓库又有什么区别呢？"><a href="#这些仓库又有什么区别呢？" class="headerlink" title="这些仓库又有什么区别呢？"></a>这些仓库又有什么区别呢？</h3><p><strong>maven中央仓库</strong>（<a href="http://repo1.maven.org/maven2/）是由Sonatype公司提供的服务，它是Apache" target="_blank" rel="noopener">http://repo1.maven.org/maven2/）是由Sonatype公司提供的服务，它是Apache</a> Maven、SBT和其他构建系统的默认仓库，并能很容易被Apache Ant/Ivy、Gradle和其他工具所使用。开源组织例如Apache软件基金会、Eclipse基金会、JBoss和很多个人开源项目都将构件发布到中央仓库。 maven中央仓库已经将内容浏览功能禁掉了。</p><p><strong>jcenter仓库</strong>（<a href="https://jcenter.bintray.com" target="_blank" rel="noopener">https://jcenter.bintray.com</a> ）是由JFrog公司提供的Bintray中的Java仓库。它是当前世界上最大的Java和Android开源软件构件仓库。 所有内容都通过内容分发网络（CDN）使用加密https连接获取。JCenter是Goovy Grape内的默认仓库，Gradle内建支持（jcenter()仓库），非常易于在（可能除了Maven之外的）其他构建工具内进行配置。</p><p>JCenter相比mavenCenter构件更多，性能也更好。但还是有些构件仅存在mavenCenter中。</p><p><strong>google（）</strong>存储库是Google maven资源库的快捷方式。 它是在Gradle 4.x +中引入的。 使用的实际存储库URL是“<a href="https://dl.google.com/dl/android/maven2/”，" target="_blank" rel="noopener">https://dl.google.com/dl/android/maven2/”，</a> 也可以使用 maven { url ‘<a href="https://maven.google.com&#39;" target="_blank" rel="noopener">https://maven.google.com&#39;</a> }<br>但是 google（），则需要Gradle 4.x +，Android Studio 3.x +和Android 3.x +的Gradle插件。</p><p><strong>maven (阿里云)</strong>  maven.aliyun.com代理了很多公共的maven仓库。使用maven.aliyun.com中的仓库地址作为下载源，速度更快更稳定。<br><a href="https://maven.aliyun.com/repository/public" target="_blank" rel="noopener">https://maven.aliyun.com/repository/public</a>   是 central仓和jcenter仓的聚合仓 经过测试发现，可以代替 central 和 jcenter ，把阿里云的这个放到第一位会加快同步速度。</p><p><a href="https://i.loli.net/2019/05/27/5cebf9966068b23466.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cebf9966068b23466.png" alt="仓库4.png"></a></p><p>阿里云除了代理了 mavenCentral, jcenter还有 上面的 google()  基本上主流的 仓库都有, 在国内这个网络环境下, 使用阿里云的代理仓库是一个挺好的选择.</p><h3 id="什么是Maven？"><a href="#什么是Maven？" class="headerlink" title="什么是Maven？"></a>什么是Maven？</h3><p>Maven 是一个项目管理和自动构建工具。是一个软件（特别是Java软件）项目管理以及自动构建工具，由Apache软件基金会所提供。是基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。<br>Maven也可以被利用与构建和管理各种项目，例如：C#、Ruby、Scala和其他语言编写的项目。<br>Maven项目使用项目对象模型（Project Object Modle，POM）来配置项目，对象模型存储在名为pom.xm的文件中。 </p><h3 id="什么是Gradle？"><a href="#什么是Gradle？" class="headerlink" title="什么是Gradle？"></a>什么是Gradle？</h3><p>Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建工具，是一款通用灵活的构建工具，支持maven， Ivy仓库，支持传递性依赖管理，而不需要远程仓库或者是pom.xml和ivy.xml配置文件，基于Groovy（DSL语言，所谓的DSL是指这个语言应用在特定的领域，而类似Java这样是DCL语言，可以运用在普通的各个领域），而不是传统的xml语言，build脚本使用Groovy编写。当前支持的语言仅限于Java、Groovy、Scala、Kotlin。计划未来支持更多的语言。<br> Gradle改良了过去Maven、Ant带给开发者的问题，也已经成为Android Studio内置封装部署工具</p><h3 id="Android支持的Maven仓库："><a href="#Android支持的Maven仓库：" class="headerlink" title="Android支持的Maven仓库："></a>Android支持的Maven仓库：</h3><ul><li>1.mavenCentral 是最早的 maven 中央仓库</li><li>2.jcenter 是 Android Studio 0.8 版本起的默认 maven 中央仓库</li><li>3.本机的仓库</li><li>4.部署在内网服务器的私有仓库</li></ul><p>上面也说了，我们可以把自己写的优秀代码共享到这些代码仓库中供全世界 开发者使用，但是由于公司的项目很多不能公开，只可在公司范围使用，又需要在不同项目中可以方便接入，在后续功能修改时 又能通过版本控制 使用修改前后的功能均可正常使用， 这个时候可以 搭建私有 maven 仓库，部署我们的公共组件代码，就可以方便使用了。</p><h3 id="使用Nexus搭建-maven-私服"><a href="#使用Nexus搭建-maven-私服" class="headerlink" title="使用Nexus搭建 maven 私服"></a>使用Nexus搭建 maven 私服</h3><p>下面演示在window上的安装过程</p><h4 id="1-下载Nexus"><a href="#1-下载Nexus" class="headerlink" title="1.下载Nexus"></a>1.下载Nexus</h4><p>下载地址：<a href="http://www.sonatype.com/download-oss-sonatype" target="_blank" rel="noopener">http://www.sonatype.com/download-oss-sonatype</a><br><a href="https://i.loli.net/2019/05/27/5cebf99662a1697739.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cebf99662a1697739.png" alt="仓库5.png"></a></p><h4 id="2-解压zip文件，配置nexus下bin目录全局变量"><a href="#2-解压zip文件，配置nexus下bin目录全局变量" class="headerlink" title="2.解压zip文件，配置nexus下bin目录全局变量"></a>2.解压zip文件，配置nexus下bin目录全局变量</h4><p><a href="https://i.loli.net/2019/05/27/5cebf99587bb771985.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cebf99587bb771985.png" alt="仓库6.png"></a></p><p>然后打开我的电脑-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量 </p><p>在path 中配置 上面的bin 文件夹的路径进去 F:\Downloads\nexus-3.16.1-02-win64\nexus-3.16.1-02\bin</p><h4 id="3-安装nexus服务，"><a href="#3-安装nexus服务，" class="headerlink" title="3.安装nexus服务，"></a>3.安装nexus服务，</h4><p>以管理员身份运行 cmd 进入 上面bin的文件夹下， 运行nexus.exe/install Nexus Service命令<br>查看服务里就能看到</p><p><a href="https://i.loli.net/2019/05/27/5cebf99540d6044503.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cebf99540d6044503.png" alt="仓库7.png"></a></p><h4 id="4-启动服务"><a href="#4-启动服务" class="headerlink" title="4.启动服务,"></a>4.启动服务,</h4><p>启动这个服务，稍等一会时间，在浏览器中访问 <a href="http://localhost:8081/。就能够看到这个页面" target="_blank" rel="noopener">http://localhost:8081/。就能够看到这个页面</a></p><p><a href="https://i.loli.net/2019/05/27/5cebf9954b73738490.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cebf9954b73738490.png" alt="仓库8.png"></a></p><p>默认的用户名和密码登录（admin/admin123） 目前为止 服务搭建成功。</p><p>仓库的详细配置过程，请移步到官方网站<br><a href="http://books.sonatype.com/nexus-book/reference3/admin.html#admin-repositories" target="_blank" rel="noopener">http://books.sonatype.com/nexus-book/reference3/admin.html#admin-repositories</a></p><p>下面来看怎么使用的问题；</p><h3 id="上传-aar-到我们搭建的私服上-步骤"><a href="#上传-aar-到我们搭建的私服上-步骤" class="headerlink" title="上传 aar 到我们搭建的私服上 步骤"></a>上传 aar 到我们搭建的私服上 步骤</h3><h4 id="1-Nexus创建自己的仓库"><a href="#1-Nexus创建自己的仓库" class="headerlink" title="1. Nexus创建自己的仓库"></a>1. Nexus创建自己的仓库</h4><p>访问：<a href="http://localhost:8081/nexus，" target="_blank" rel="noopener">http://localhost:8081/nexus，</a><br>先创建一个你要上传的仓库信息：</p><p><a href="https://i.loli.net/2019/05/27/5cebf995491f814187.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cebf995491f814187.png" alt="仓库9.png"></a></p><p>点击create repository   </p><p><a href="https://i.loli.net/2019/05/27/5cebf9952617494095.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cebf9952617494095.png" alt="仓库10.png"></a></p><p><a href="https://i.loli.net/2019/05/27/5cebfb06469b367897.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cebfb06469b367897.png" alt="仓库11.png"></a></p><p>name那输入你想创建的名称，如 younger<br>然后点创建，就可以看到了自己的仓库 <a href="http://10.1.1.147:8081/repository/younger/" target="_blank" rel="noopener">http://10.1.1.147:8081/repository/younger/</a>   （此ip为我自己电脑局域网ip）</p><h4 id="2-Android-Studio-配置"><a href="#2-Android-Studio-配置" class="headerlink" title="2. Android Studio 配置"></a>2. Android Studio 配置</h4><p>新建一个module，这个module就是你要编译的aar<br>module下gradle配置如下，<br>添加代码：<br>apply plugin:’maven’</p><p>和</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uploadArchives</span> &#123;</span><br><span class="line">    configuration = configurations.archives</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            repository(url: <span class="string">'http://10.1.1.147:8081/repository/younger/'</span>) &#123;</span><br><span class="line">                authentication(userName: <span class="string">'admin'</span>, <span class="literal">password</span>: <span class="string">'admin123'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">pom</span>.<span class="keyword">project</span> &#123;</span><br><span class="line">                version <span class="string">'0.0.1'</span></span><br><span class="line">                artifactId <span class="string">'testmaven'</span></span><br><span class="line">                groupId <span class="string">'demo.younger.com'</span></span><br><span class="line">                packaging <span class="string">'aar'</span></span><br><span class="line">                <span class="literal">description</span> <span class="string">'update version 0.0.1'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>groupId，version要注意填好。<br>然后，在Gradle projects列表中可以看到upload的Task<br>点击后即可编译上传，success后就可以了。</p><p><a href="https://i.loli.net/2019/05/27/5cebfb085bfe458955.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cebfb085bfe458955.png" alt="仓库12.png"></a></p><p><a href="https://i.loli.net/2019/05/27/5cebfb095474414578.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cebfb095474414578.png" alt="仓库13.png"></a></p><p>可以看到编译成功 ，在Nexus后台可以看到：<br><a href="https://i.loli.net/2019/05/27/5cebfb05d121946202.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cebfb05d121946202.png" alt="仓库14.png"></a></p><h4 id="3-Android-Studio-中引用"><a href="#3-Android-Studio-中引用" class="headerlink" title="3. Android Studio 中引用"></a>3. Android Studio 中引用</h4><p>//添加仓库<br>在根gradle 中添加 </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line"><span class="comment">//新增</span></span><br><span class="line">        maven &#123;</span><br><span class="line">            url <span class="string">'http://10.1.1.147:8081/repository/younger/'</span>  </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在项目的gradle-中使用"><a href="#在项目的gradle-中使用" class="headerlink" title="在项目的gradle 中使用"></a>在项目的gradle 中使用</h4><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implementation</span> <span class="string">'demo.younger.com:testmaven:0.0.1'</span></span><br></pre></td></tr></table></figure><p>就可以正常引用了， 可以看到上面的顺序是 groupId ：artifactId： version </p><p>也可以在   External Libraries  查看到</p><p><a href="https://i.loli.net/2019/05/27/5cebfb07f089a93771.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cebfb07f089a93771.png" alt="仓库15.png"></a></p><p>项目中也可以引用啦 </p><p>目前项目中weex就是采用这种方式， 搭建一个nexus 私服，把weex 官方的sdk 下载下来，我们根据项目需要，自行实现很多不同的功能，<br>而这些功能在不同的项目都可以用到，就统一放到私服上，在我们具体的项目中，只需要简单设置，就可以非常方便的使用这些功能，<br>如果新增了什么功能，可以直接把代码上传到公共组件中，升级版本， 项目中用的时候只需要改成相应的版本号就可以方便使用到最新的功能。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以发现，创建私服，上传aar文件， 引用都非常简单， 具体有没有必要使用还是需要根据自身实际情况来看，那些公共仓库上的内容可以优先使用阿里云的代理仓库，这样会加快同步速度，自己内部使用或者比较特殊的内容就可以放到私服上了，同样是特别方便。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上篇文章 &lt;a href=&quot;https://youngerdev.com/Android中SO文件使用.html&quot;&gt;从ARM暂停与华为合作谈起 Android中SO兼容的那些事&lt;/a&gt; 中提到了我们是用自己私服上的weex sdk 出的问题继而解决的问题,今天就来介绍下我们
      
    
    </summary>
    
    
      <category term="Android私服" scheme="http://youngerdev.com/tags/Android%E7%A7%81%E6%9C%8D/"/>
    
  </entry>
  
  <entry>
    <title>从ARM暂停与华为合作谈起 Android中SO兼容的那些事</title>
    <link href="http://youngerdev.com/Android%E4%B8%ADSO%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8.html"/>
    <id>http://youngerdev.com/Android中SO文件使用.html</id>
    <published>2019-05-08T15:18:03.000Z</published>
    <updated>2019-05-30T00:24:29.407Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>因为包含来自美国的技术，ARM（英国）已经要求员工“停止所有与华为及其子公司正在生效的合约、支持及未决约定”</p></blockquote><p>从最近的新闻来看，美国的贸易禁令使得华为公司腹背受敌，ARM彻底暂停与华为合作已成定局，最新款的芯片技术肯定是用不上了，不过华为已经获得了ARMv8的永久授权。但是ARM是什么样的存在？ 为什么对华为有这么大的影响力呢，事实上 ARM处理器 已经一统移动端了。今天就来谈谈 ARM 与 Android SO 的那些事。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景:"></a>背景:</h3><p>公司某项目新上功能部分页面使用 weex 来做的，测试过程中发现 weex 页面在某些手机上出现异常，经过排查定位到是 SO 库的问题，下面是这个问题的解决过程的一个记录，希望能对遇到类似问题的同学提供一些帮助。</p><h3 id="什么问题"><a href="#什么问题" class="headerlink" title="什么问题?"></a>什么问题?</h3><p>公司某项目 V1.2.0版本最初上线时，使用的 weex 是官方的 SDK 的接入方式， 接下来 App版本需要把官方的 SDK 替换成我们自己私服上的 SDK（因为私服上有我们针对自己项目需要，自定义了许多控件和公共组件） ，替换后，出现 weex 页面加载异常的问题（白屏）</p><p>报错信息如下：</p><p><a href="https://i.loli.net/2019/05/27/5cec05e1c1b9b32104.jpeg" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cec05e1c1b9b32104.jpeg" alt="so1.jpeg"></a></p><p>我们注意到，上面有一行错误是 invokeInitFramework java.lang.UnsatisfiedLinkError:    见过该错误的开发者都知道，这个是 JNI 相关的错误信息，根据错误信息能看到是 weex 相关的 JNI 调用出了问题，由JNI 又想到了 SO 库文件， 那就引出今天的话题。</p><h3 id="什么是-SO-文件及SO-应用？"><a href="#什么是-SO-文件及SO-应用？" class="headerlink" title="什么是 SO 文件及SO 应用？"></a>什么是 SO 文件及SO 应用？</h3><p>SO（shared object，共享库）是机器可以直接运行的二进制代码</p><ul><li><p>SO 机制让开发者最大化利用已有的 C 和 C++ 代码，达到复用的效果，利用软件世界积累了几十年的优秀代码；</p></li><li><p>SO 是二进制，没有解释编译的开销，用SO实现的功能比纯java实现的功能要快；</p></li><li><p>SO 内存分配不受 Dalivik/ART 的单个应用限制，减少 OOM；</p></li><li><p>相对于java代码，二进制代码的反编译难度更大，一些核心代码可以考虑放在 SO 中。</p></li></ul><p>在Android 中 提到 SO 就不能不提 ABI </p><h3 id="ABI"><a href="#ABI" class="headerlink" title="ABI"></a>ABI</h3><p>应用程序二进制接口（Application Binary Interface）</p><p>定义了其所对应的CPU架构能够执行的二进制文件（特别是.so文件）的格式规范。在 Android 系统上，不同 Android 手机使用不同的 CPU，因此支持不同的指令集。CPU 与指令集的每种组合都有其相应的应用二进制界面（或 ABI）。</p><p>ABI 可以非常精确地定义应用的机器代码在运行时如何与系统交互。 您必须为应用要使用的每个 CPU 架构指定 ABI：armeabi，armeabi-v7a，arm64-v8a，x86，x86_64，mips，mips64；</p><p>目前 Android 共支持七种不同类型的 CPU 架构，分别是：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)</p><p><a href="https://i.loli.net/2019/05/27/5cec05ede59f285026.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cec05ede59f285026.png" alt="so11.png"></a></p><h3 id="SO（CPU）的兼容"><a href="#SO（CPU）的兼容" class="headerlink" title="SO（CPU）的兼容"></a>SO（CPU）的兼容</h3><p>每一个 CPU 架构对应一个 ABI，一个 CPU 属于某一种架构，多核 CPU 属于相同架构才能一起工作，很多设备仅支持一种 CPU 架构。</p><p>如果你要完美兼容所有类型的机型，理论上是要在的 libs 目录下放置各个架构平台的 SO 文件。</p><p>但项目体积也会变得非常庞大。是否一定需要带入这么多SO文件去兼容呢？答案是否定的。</p><p>根据目前Android共支持七种不同类型的CPU架构，其兼容特点可总结如下：</p><blockquote><p>armeabi设备只兼容armeabi；</p></blockquote><blockquote><p>armeabi-v7a设备兼容armeabi-v7a、armeabi；</p></blockquote><blockquote><p>arm64-v8a设备兼容arm64-v8a、armeabi-v7a、armeabi；</p></blockquote><blockquote><p>X86设备兼容X86、armeabi；</p></blockquote><blockquote><p>X86_64设备兼容X86_64、X86、armeabi；</p></blockquote><blockquote><p>mips64设备兼容mips64、mips；</p></blockquote><blockquote><p>mips只兼容mips；</p></blockquote><p>armeabi 的 SO 文件基本上可以说是兼容目前市面上的大部分手机，它能运行在除了mips和mips64的设备上，但在非 armeabi 设备上运行性能会有所损耗；</p><p>64位的CPU架构总能向下兼容其对应的32位指令集，如：x86_64兼容X86，arm64-v8a兼容armeabi-v7a，mips64兼容mips；</p><p>总结成一句话就是， 新的CPU 架构总能向下兼容；</p><p>所以知道这些信息后，查看公司其他项目怎么用的, 发现其他项目, 在 build.gradle 中关于 ndk.abiFilters  都是这样写的：</p><p><a href="https://i.loli.net/2019/05/27/5cec05e19113650893.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cec05e19113650893.png" alt="so2.png"></a></p><p>而这个项目的写法是这样的：</p><p><a href="https://i.loli.net/2019/05/27/5cec05e1b164534030.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cec05e1b164534030.png" alt="so3.png"></a></p><p>区别就是这个 ndk.abiFilters  ， 既然这样写，必定有它的原因， 那就继续找，为什么要这么写，咨询相关的同事，了解到相关路径下的文件是 视频聊天、语音相关的 SO 库。</p><p>那能不能改成只支持 armeabi 或者 他们其中的部分呢。那就模拟这些情况，然后分别打出了这么多包（包的命名有点随意，这不是重点），分别在不同的手机上验证是否能正常加载 weex 。</p><p><a href="https://i.loli.net/2019/05/27/5cec05e1bda8e24077.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cec05e1bda8e24077.png" alt="so4.png"></a></p><p><a href="https://i.loli.net/2019/05/27/5cec05e1b944378415.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cec05e1b944378415.png" alt="so5.png"></a></p><p>经测试发现 armeabi 的和 armeabi +x86 的都可以正常加载 weex 页面，感觉问题这么简单就解决了，但是！！！</p><p>想到去掉这么多东西 会不会影响其他正常功能呢， 那就验证下吧，试了下视频相关功能，果不其然的 app 崩溃了。</p><p>说明上面的方向肯定是有问题，使用工具 Native libs Monitor  查看下Apk 中具体的SO 文件</p><p>首先查看下那些我们常用的App 是怎么做的，微信、QQ、支付宝等等</p><h3 id="其他公司如何适配的"><a href="#其他公司如何适配的" class="headerlink" title="其他公司如何适配的"></a>其他公司如何适配的</h3><ul><li><p>微信（只适配armeabi，有少量 v7a）；</p></li><li><p>qq（只适配armeabi，文件夹下有少量x86）；</p></li><li><p>百度地图（只适配armeabi）；</p></li><li><p>大众点评（只适配armeabi）；</p></li><li><p>google 家 （基本都是 arm64）； </p></li><li><p>支付宝 （基本都是 armeabi 的，2个x86的）；</p></li></ul><p>而且 公司别的项目App 中 用到的 face++ 的人脸识别，身份证识别 也是只提供了armeabi 的SO 文件</p><p>下图是微信的Apk 解压出的情况， 微信的lib下虽然只有armeabi-v7a一个目录，但目录内的文件仍放着v7a和 armeabi架构的SO文件，用于处理兼容带来的某些性能运算问题。</p><p><a href="https://i.loli.net/2019/05/27/5cec05ee064bf31381.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cec05ee064bf31381.png" alt="so12.png"></a></p><p>看完大公司的适配情况，然后看下我们自己 公司这几个项目，看看到底有什么区别， 还有上面打出的不同的包，相应的 SO 引入情况。</p><p>经过对比发现， 指定不同的 abi 会 在apk 中 打入相应 的文件(前提是 你有这些文件)，这就是一个过滤器，只在包中引入指定的cpu 架构的 SO 文件。</p><p><a href="https://i.loli.net/2019/05/27/5cec05e18f15246561.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cec05e18f15246561.png" alt="so6.png"></a></p><p>既然重点是 weex 加载的出了问题，然后就重点查看 weex 相关的 SO 引入情况， 既然官方的可以正常使用， 我们私服上却出了问题，然后对比使用官方的 sdk 集成方式,和我们私服上的集成方式的 SO 库有什么不同；</p><p>如图是集成weex 官方sdk 的 APK<br><a href="https://i.loli.net/2019/05/27/5cec05e1c632040457.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cec05e1c632040457.png" alt="so7.png"></a></p><p>而集成私服上的 sdk 后，只在 armv5中有 libweexjsc.so 而 armv7 中是没有这个问题的。 区别找到了，那就去私服的项目中找原因<br><a href="https://i.loli.net/2019/05/27/5cec05e1a44a363699.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cec05e1a44a363699.png" alt="so8.png"></a></p><p>并没有 armeabi-v7a 的文件，相应的 lib下也没有相应的文件夹和文件，按照一样的写法，在这加入 armeabi-v7a 相应的路径，相应的 lib 下，也新建了相应的文件夹，放入相应的文件。重新编译</p><p><a href="https://i.loli.net/2019/05/27/5cec05e159f0b86317.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cec05e159f0b86317.png" alt="so9.png"></a></p><p>再次尝试, 查看 lib 在 arm v7 和 v8a 的手机上,查看 lib 情况,发现, 在都能看到相应的 SO 文件了,</p><p>多部手机尝试， 视频聊天、语音、 weex 都正常、至此 问题得到解决。</p><p>在排查问题的过程中发现，其实这个项目 本来的 build.gradle 文件中的 arm64-v8a 写错了，以前写成了 armeabi-v8a 其实这样是无法使用到 arm64-v8a下的 so 的。</p><p>但是会向下兼容, 使用了 armeabi-v7a 中的文件，也没有报错，其实也是因祸得福，如果写正确的话，weex 在 arm64-v8a 也会加载失败，因为 官方也没有提供这样的一个文件夹和文件。</p><p>但是我们要怎么配置呢？</p><p>从目前移动端CPU市场的份额数据看，ARM架构几乎垄断，所以，除非你的用户很特殊，否则几乎可以不考虑单独编译带入X86、X86_64、mips、mips64架构SO文件。除去这四个架构之后，还要带入armeabi、armeabi-v7a、arm64-v8a 这三个不同类型，这对于一个拥有大量SO文件的应用来说，安装包的体积将会增大不少。</p><h3 id="针对不同平台，如何去适配，如何抉择"><a href="#针对不同平台，如何去适配，如何抉择" class="headerlink" title="针对不同平台，如何去适配，如何抉择"></a>针对不同平台，如何去适配，如何抉择</h3><p>目前主流的Android设备主要是 armeabi-v7a ARMv8 架构的，程序在运行的时候去加载不同平台对应的so，这是较为完美的一种解决方案，但是有时候为了减少包体积的大小，</p><p>不会同时设置 armeabi， armeabi-v7a 和 x86。根据不同的情况，可以进行不同的适配，</p><p>1.只适配 armeabi-v7a，因为目前主流机型是 ARMv7，并且 ARMv8 设备也向下兼容了armeabi-v7a， Facebook、WhatsApp、王者荣耀等就是只适配了armeabi-v7a。（Google play store下载 Native libs Monitor 进行查看）。</p><p>2.只适配 armeabi，因为 ARMv7 、ARMv8 还是 x86 都兼容 armeabi，但是性能都会有些损耗，例如ARMv7 支持硬件浮点运算等没法体现，x86 支持 armeabi 同样具有相应的损耗。</p><p>3.同时适配 armeabi-v7a 和 armeabi，既能够支持所有 ARM 架构，同时又能具有 ARMv7 支持硬件浮点运算等特性，例如Line等应用。</p><p>4.同时适配 x86 和 armeabi，既能支持所有 ARM 架构，又能支持x86架构，唯一的缺点就是没有了ARMv7 支持硬件浮点运算等一系列特性，例如QQ。</p><p>5.同时适配 armeabi， armeabi-v7a 和 x86，在性能方面来说是较为完美的方案，只是APK的大小也会随之变大。</p><p>6.还有其他的一些方案，例如微信只适配了armeabi，但是对于某些需要利用 ARMv7 支持硬件浮点运算等一系列特性的操作，在armeabi目录下存在v7对应的so文件，通过代码判断加载不同的so文件。即达到了减少APK大小的目的，又能达到适配ARMv7等架构以便使用其架构的一些新特性的目的。</p><p>就目前市场份额而言，绝大部分的设备都已经是armeabi-v7a、arm64-v8a，可以考虑只保留armeabi-v7a架构的SO文件，这样能获得更好的性能效果。所以我们的 这个项目选择采用第3种方案；<br><a href="https://i.loli.net/2019/05/27/5cec05e1321ca43637.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/05/27/5cec05e1321ca43637.png" alt="so10.png"></a></p><p>现在把这个项目中的 ndk.abiFilters 配置成上图所示，几乎覆盖所有机型，weex 能够正常加载，暂时没有发现影响其他功能，这个问题也算是得到解决。在不影响太多性能的情况下，也可以明显减少包的体积。</p><h3 id="总结下常见的-引入-so文件的错误"><a href="#总结下常见的-引入-so文件的错误" class="headerlink" title="总结下常见的 引入.so文件的错误"></a>总结下常见的 引入.so文件的错误</h3><h4 id="1-使用android高版本平台版本编译的-so文件运行在android低版本的设备上"><a href="#1-使用android高版本平台版本编译的-so文件运行在android低版本的设备上" class="headerlink" title="1.使用android高版本平台版本编译的.so文件运行在android低版本的设备上"></a>1.使用android高版本平台版本编译的.so文件运行在android低版本的设备上</h4><p>使用NDK时，你可能会倾向于使用最新的编译平台，但事实上这是错误的，因为NDK平台不是向下兼容的，而是向上兼容的。推荐使用app的minSdkVersion对应的编译平台。</p><p>这也意味着当你引入一个预编译好的.so文件时，你需要检查它编译时所用的平台版本。</p><h4 id="2-没有为每个支持的CPU架构提供对应的-so文件"><a href="#2-没有为每个支持的CPU架构提供对应的-so文件" class="headerlink" title="2.没有为每个支持的CPU架构提供对应的.so文件"></a>2.没有为每个支持的CPU架构提供对应的.so文件</h4><p>arm64-v8a是可以向下兼容的，但前提是你的项目里面没有arm64-v8a的文件夹，如果你有两个文件夹armeabi和arm64-v8a，两个文件夹，armeabi里面有a.so 和 b.so,arm64-v8a里面只有a.so，</p><p>那么arm64-v8a的手机在用到b的时候发现有arm64-v8a的文件夹，发现里面没有b.so，就报错了，</p><p>所以这个时候删掉arm64-v8a文件夹，这个时候手机发现没有适配arm64-v8a，就会直接去找armeabi的so库，或者把 arm64-v8a文件夹 的 b.so补齐。</p><h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><p><a href="https://zhuanlan.zhihu.com/p/21302804" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21302804</a></p><p><a href="https://www.zhihu.com/question/36893314/answer/78467097" target="_blank" rel="noopener">https://www.zhihu.com/question/36893314/answer/78467097</a></p><p><a href="https://blog.csdn.net/zophar_development/article/details/84329054" target="_blank" rel="noopener">https://blog.csdn.net/zophar_development/article/details/84329054</a></p><p><a href="https://www.cnblogs.com/janehlp/p/7473240.html" target="_blank" rel="noopener">https://www.cnblogs.com/janehlp/p/7473240.html</a></p><p><a href="https://www.jianshu.com/p/cb05698a1968" target="_blank" rel="noopener">https://www.jianshu.com/p/cb05698a1968</a></p><p><a href="https://www.jianshu.com/p/cb15ba69fa89" target="_blank" rel="noopener">https://www.jianshu.com/p/cb15ba69fa89</a></p><p>等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;因为包含来自美国的技术，ARM（英国）已经要求员工“停止所有与华为及其子公司正在生效的合约、支持及未决约定”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从最近的新闻来看，美国的贸易禁令使得华为公司腹背受敌，ARM彻底暂停与华为合作已成定局，最新款的
      
    
    </summary>
    
    
      <category term="Android SO兼容" scheme="http://youngerdev.com/tags/Android-SO%E5%85%BC%E5%AE%B9/"/>
    
      <category term="SO" scheme="http://youngerdev.com/tags/SO/"/>
    
      <category term="华为" scheme="http://youngerdev.com/tags/%E5%8D%8E%E4%B8%BA/"/>
    
      <category term="arm" scheme="http://youngerdev.com/tags/arm/"/>
    
  </entry>
  
  <entry>
    <title>开站顺利</title>
    <link href="http://youngerdev.com/%E5%BC%80%E7%AB%99%E9%A1%BA%E5%88%A9.html"/>
    <id>http://youngerdev.com/开站顺利.html</id>
    <published>2019-02-18T14:12:37.000Z</published>
    <updated>2019-05-29T14:33:33.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这是Younger-的第一篇内容"><a href="#这是Younger-的第一篇内容" class="headerlink" title="这是Younger 的第一篇内容"></a>这是Younger 的第一篇内容</h2><p><strong>终于我也有自己的个人网站了</strong></p><p>昨天是周日,下午开始弄这个,<strong>申请域名</strong>, <strong>搭建网站</strong>,整个过程真的好简单,以前一直以为很难的,就一直没有动手的去弄; 目前来看, <strong>困难都是自己想象出来的, 真正动手去做,就会发现,也没有那么难,真正需要做的就是行动, 勇敢踏出第一步</strong></p><h4 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h4><p>域名是在  <a href="https://new.namesilo.com/" target="_blank" rel="noopener">namesilo</a> 买的, 用了优惠码后一年也就是不到50元,支持支付宝支付,方便至极 ,如果有需要可以寻找网上的优惠码, 可以节省1美元, 我这个域名买下来一年5.99美元,也就是不到45块钱,可谓是相当的划算了.</p><p>关于域名商的选择我也是查了下资料, 之所以没有选择国内的服务商, 主要是众所周知的原因, 国内的需要备案, 且你的域名随时可能被关掉等不安全因素,  还是在国际知名的大的域名商买比较靠谱, namesilo 这个打的广告比较少, 说是让利给消费者, 的确是很便宜,  我是对比了多家, 发现这家便宜的, 还有 <a href="www.namecheap.com">namecheap</a> 也比较便宜. 这个还是见仁见智了, 想买哪个都行, 续费便宜, 服务好就行.</p><h4 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h4><p>使用的是 github.io + hexo 搭建的,<br>过程非常的简单, 感谢各位大佬的<a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">教程</a></p><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官网的文档</a> 也很详细,还有视频教程,<br>另外还有好多主题供选择; 傻瓜式安装.每一步都有详细的教程, 然后就成了我现在弄的这个样子, 后续我肯定还会继续更新的.</p><p>今天简单弄了一下,记录一下, 虽然用的也都是别人的轮子,但还是很开心呀!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;这是Younger-的第一篇内容&quot;&gt;&lt;a href=&quot;#这是Younger-的第一篇内容&quot; class=&quot;headerlink&quot; title=&quot;这是Younger 的第一篇内容&quot;&gt;&lt;/a&gt;这是Younger 的第一篇内容&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;终于我也有自
      
    
    </summary>
    
    
      <category term="网站搭建" scheme="http://youngerdev.com/tags/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"/>
    
      <category term="域名购买" scheme="http://youngerdev.com/tags/%E5%9F%9F%E5%90%8D%E8%B4%AD%E4%B9%B0/"/>
    
      <category term="hexo" scheme="http://youngerdev.com/tags/hexo/"/>
    
      <category term="github" scheme="http://youngerdev.com/tags/github/"/>
    
      <category term="namesilo" scheme="http://youngerdev.com/tags/namesilo/"/>
    
  </entry>
  
</feed>

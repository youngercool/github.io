<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ListView 优化及相关问题总结]]></title>
    <url>%2FListView-%E4%BC%98%E5%8C%96%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[ListView 优化最近在做项目过程中频繁使用列表，今天抽空总结下过程中遇到的问题，下面会有具体对应的解决办法； 1.listView 外套一层ScrollView 的问题，就是listView 只显示一行或者两行， 我发现这个问题在 RecycleView 上也存在， 在RecycleView外套一层 ScrollView也会出现只显示一行的问题，滑动只能在 一行的高度内滑动。这问题下面有具体解决方案，说下我是怎么解决的吧，因为我要实现的是9宫格的图片展示，本来是用的RecycleView 来实现的，出现了这个问题，我就尝试把recyclerView 换成了GridView 了，因为GridView 本身就支持多行展示，发现就没有这个问题了，套了ScrollView 也正常展示； 也是listView 在嵌套ScrollView 中的问题，在某款三星手机上，这个手机的虚拟按键，可以锁定和解锁定， 发现在切换锁定和解锁定中，会导致原来的多行的图片变成单行， 在别的手机上就没有这个问题， 这个奇怪的现象，最终还是以GridView 替换掉listView 解决的。 listView 添加 headerView的问题， 需要注意的是 添加进去的 HeaderView 就占据了第0位，所以在使用的 onItemClick 的时候，需要-1， addfooterView的时候可以用 view.getFooterViewsCount() 是否等于0来判断，避免多次添加。 由于listView 会复用viewHolder ，所以我们在getView 中 显示隐藏的设置一定要配套使用，if里有显示，在else 中就要 隐藏。 优化步骤：使用 RecycleView 代替listview 1.重用ConvertView; 2.使用View Holder模式； 3.使用异步线程加载图片（一般都是直接使用图片库加载，如Glide, Picasso）；建议: 1.在adapter的getView方法中尽可能的减少逻辑判断，特别是耗时的判断； 2.避免GC 3.在快速滑动时不要加载图片； 4.将ListView的scrollingCache和animateCache这两个属性设置为false（默认是true）; 5.尽可能减少List Item的Layout层次（如可以使用RelativeLayout替换LinearLayout，或使用自定的View代替组合嵌套使用的Layout） ListView 嵌套 ScrollViewListview不能显示正常的条目，只显示一条或二条 这是因为：由于listView在scrollView中无法正确计算它的大小, 故只显示一行。 解决方案:1. 方法一：重写ListView, 覆盖onMeasure()方法1234567891011121314151617181920212223WrapperListView.java:public class WrapperListView extends ListView &#123; public WrapperListView(Context context) &#123; super(context); &#125; public WrapperListView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public WrapperListView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; public WrapperListView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context, attrs, defStyleAttr, defStyleRes); &#125; /** * 重写该方法，达到使ListView适应ScrollView的效果 */ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2, MeasureSpec.AT_MOST); super.onMeasure(widthMeasureSpec, expandSpec); &#125;&#125; 2.方法二：动态设置listview的高度，不需要重写ListView只需要在setAdapter之后调用如下方法即可： 123456789101112131415161718192021public void setListViewHeightBasedOnChildren(ListView listView) &#123; // 获取ListView对应的Adapter ListAdapter listAdapter = listView.getAdapter(); if (listAdapter == null) &#123; return; &#125; int totalHeight = 0; for (int i = 0, len = listAdapter.getCount(); i &lt; len; i++) &#123; // listAdapter.getCount()返回数据项的数目 View listItem = listAdapter.getView(i, null, listView); // 计算子项View 的宽高 listItem.measure(0, 0); // 统计所有子项的总高度 totalHeight += listItem.getMeasuredHeight(); &#125; ViewGroup.LayoutParams params = listView.getLayoutParams(); params.height = totalHeight + (listView.getDividerHeight() * (listAdapter.getCount() - 1)); // listView.getDividerHeight()获取子项间分隔符占用的高度 // params.height最后得到整个ListView完整显示需要的高度 listView.setLayoutParams(params); &#125; 这时最好给ListView之外嵌套一层LinearLayout，不然有时候这种方法会失效 3.方法三：在xml文件中，直接将Listview的高度写死可以确定的是：这种方式可以改变ListView的高度，但是，还有一个严重的问题就是listview的数据是可变动的，除非你能正确的写出listview的高度，否则这种方式就是个鸡肋。 4. addHeadView()如果只有数据 layout 完全没有必要嵌套 ScrollView 的.之说以需要嵌套,很多是在listView 头部或者底部多了一部分Layout ,这个时候可以尝试 listView 的 addHeadView() 尝试解决 在一次显示ListView的界面时，getView会被执行几次？比如有5组数据要填充到listView。listView会先调用onMeasure，此时会调用5次getView。然后才调用onLayout，此时又会调用5次getView，这样就重复了。所以导致多次调用getView方法 的确调用了三遍 解决办法: ListView 的高度 从 wrap_content 改成 match_patent 或者一个固定值,就能减少getview 调用次数 或者重写 listView 的onMasure onLayout 方法 赋值 一个变量 检测 是测量还是layout 测量时不加载自己写的那段逻辑 listview失去焦点怎么处理？在listview子布局里面写，可以解决焦点失去的问题android:descendantFocusability=”blocksDescendants” ListView 优化 1.首先，虽然大家都知道，还是提一下，利用好 convertView 来重用 View，切忌每次 getView() 都新建。ListView 的核心原理就是重用 View。ListView 中有一个回收器，Item 滑出界面的时候 View 会回收到这里，需要显示新的 Item 的时候，就尽量重用回收器里面的 View。 2.利用好 View Type，例如你的 ListView 中有几个类型的 Item，需要给每个类型创建不同的 View，这样有利于 ListView 的回收，当然类型不能太多 3.尽量让 ItemView 的 Layout 层次结构简单，这是所有 Layout 都必须遵循的 4.善用自定义 View，自定义 View 可以有效的减小 Layout 的层级，而且对绘制过程可以很好的控制； 5.尽量能保证 Adapter 的 hasStableIds() 返回 true，这样在 notifyDataSetChanged() 的时候，如果 id 不变，ListView 将不会重新绘制这个 View，达到优化的目的； 6.每个 Item 不能太高，特别是不要超过屏幕的高度，可以参考 Facebook 的优化方法，把特别复杂的 Item 分解成若干小的 Item， 7.为了保证 ListView 滑动的流畅性，getView() 中要做尽量少的事情，不要有耗时的操作。特别是滑动的时候不要加载图片，停下来再加载，这个库可以帮助你 Glide：https://github.com/bumptech/glide 8.使用 RecycleView 代替。 ListView 每次更新数据都要 notifyDataSetChanged()，有些太暴力了。RecycleView 在性能和可定制性上都有很大的改善，推荐使用。]]></content>
      <tags>
        <tag>Android listView</tag>
        <tag>ListView优化</tag>
        <tag>列表优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站优化]]></title>
    <url>%2F%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[网站在今年2月份就创建了，但是一直没有怎么优化。最近几天，简单美化了一下现在就把相关的优化网站列一下，希望对读者有点帮助。 Github Pages + Hexo 博客搭建，Next主题个性化修改 有很多链接，包括从创建到优化，还有视频教程。 Hexo博客主题安装及Next主题个性化修改 不得不说，这个对我帮助很大。 hexo - Next 主题添加评论功能 这个是给我们的网站加评论的， 我选择 Valine 评论系统 ，我希望可以匿名评论。 后续还有 seo 优化还没有做，这个会继续更新的。]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>页面优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中公共代码仓库与私服的使用]]></title>
    <url>%2FAndroid%E4%B8%AD%E5%85%AC%E5%85%B1%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93%E4%B8%8E%E7%A7%81%E6%9C%8D%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[上篇文章 从ARM暂停与华为合作谈起 Android中SO兼容的那些事 中提到了我们是用自己私服上的weex sdk 出的问题继而解决的问题,今天就来介绍下我们的私服, 并手把手教会你怎么创建并使用私服. 背景随着公司业务发展，项目越来越大，项目有好几个，项目虽然具体业务不同，但是其中也有很多相同的功能， 比如都有 weex 需求，网络请求、 图片处理、视频处理等等共同的需求，如果每个项目都重新写一遍，实现一遍，势必影响进度，重复造轮子的问题，项目进展缓慢，所以 就需要一种方式来避免这种重复劳动，彻底解决这种问题。 解决办法 : 使用组件化的思想， 把公共的组件抽离出来，和主项目的关系是依赖主项目的关系。module 是以 library的形式存在于整个project 中，依赖于主工程。在需要使用的时候，引入即可。类似我们使用 recyclerview butterknife 之类的这些的功能， 这些内容有的是 Android官方提供的支持，有的是国内外优秀开发者开源出来的控件，我们可以很方便的集成到项目中。如下图： 知名仓库介绍目前有 jcenter（） ，mavenCentral（）， google（） 等等仓库中心，这些仓库是用来保存代码的，组织或者个人开发者 开源出很多优秀的代码，工具，控件，上传到这些仓库中，我们可以通过 在 gradle 中配置相应的仓库地址 ，就可以方便使用相应的代码， 而内部使用的组件，不适合开源的可以自己搭建 私有仓库，内网使用，还有一些需要借助代理访问，国内访问起来特别慢或者无法访问的内容，也可以上传到我们的私服上，能够很好地提高效率，减少同步等待时间类似下图 我们在其中一个项目中使用的 仓库地址： 我们通过在 gradle 中配置相应的依赖，项目在 build 完成后就会将相应的 依赖工程代码 下载到 项目中， 可以在project 模式下 查看 External Libraries 看到实际下载下来的代码。 下面分别介绍下 这几个仓库，和私有仓库的搭建 jcenter网页地址 http://jcenter.bintray.com/ mavenCentral网页地址http://central.maven.org/maven2/ google网页地址 https://dl.google.com/dl/android/maven2/ 其他仓库以阿里云为例网页地址 http://maven.aliyun.com/nexus/content/repositories/jcenter/ 上图中已经展示了 在项目中的配置这些仓库的方式。 这些仓库又有什么区别呢？maven中央仓库（http://repo1.maven.org/maven2/）是由Sonatype公司提供的服务，它是Apache Maven、SBT和其他构建系统的默认仓库，并能很容易被Apache Ant/Ivy、Gradle和其他工具所使用。开源组织例如Apache软件基金会、Eclipse基金会、JBoss和很多个人开源项目都将构件发布到中央仓库。 maven中央仓库已经将内容浏览功能禁掉了。 jcenter仓库（https://jcenter.bintray.com ）是由JFrog公司提供的Bintray中的Java仓库。它是当前世界上最大的Java和Android开源软件构件仓库。 所有内容都通过内容分发网络（CDN）使用加密https连接获取。JCenter是Goovy Grape内的默认仓库，Gradle内建支持（jcenter()仓库），非常易于在（可能除了Maven之外的）其他构建工具内进行配置。 JCenter相比mavenCenter构件更多，性能也更好。但还是有些构件仅存在mavenCenter中。 google（）存储库是Google maven资源库的快捷方式。 它是在Gradle 4.x +中引入的。 使用的实际存储库URL是“https://dl.google.com/dl/android/maven2/”， 也可以使用 maven { url ‘https://maven.google.com&#39; }但是 google（），则需要Gradle 4.x +，Android Studio 3.x +和Android 3.x +的Gradle插件。 maven (阿里云) maven.aliyun.com代理了很多公共的maven仓库。使用maven.aliyun.com中的仓库地址作为下载源，速度更快更稳定。https://maven.aliyun.com/repository/public 是 central仓和jcenter仓的聚合仓 经过测试发现，可以代替 central 和 jcenter ，把阿里云的这个放到第一位会加快同步速度。 阿里云除了代理了 mavenCentral, jcenter还有 上面的 google() 基本上主流的 仓库都有, 在国内这个网络环境下, 使用阿里云的代理仓库是一个挺好的选择. 什么是Maven？Maven 是一个项目管理和自动构建工具。是一个软件（特别是Java软件）项目管理以及自动构建工具，由Apache软件基金会所提供。是基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven也可以被利用与构建和管理各种项目，例如：C#、Ruby、Scala和其他语言编写的项目。Maven项目使用项目对象模型（Project Object Modle，POM）来配置项目，对象模型存储在名为pom.xm的文件中。 什么是Gradle？Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建工具，是一款通用灵活的构建工具，支持maven， Ivy仓库，支持传递性依赖管理，而不需要远程仓库或者是pom.xml和ivy.xml配置文件，基于Groovy（DSL语言，所谓的DSL是指这个语言应用在特定的领域，而类似Java这样是DCL语言，可以运用在普通的各个领域），而不是传统的xml语言，build脚本使用Groovy编写。当前支持的语言仅限于Java、Groovy、Scala、Kotlin。计划未来支持更多的语言。 Gradle改良了过去Maven、Ant带给开发者的问题，也已经成为Android Studio内置封装部署工具 Android支持的Maven仓库： 1.mavenCentral 是最早的 maven 中央仓库 2.jcenter 是 Android Studio 0.8 版本起的默认 maven 中央仓库 3.本机的仓库 4.部署在内网服务器的私有仓库 上面也说了，我们可以把自己写的优秀代码共享到这些代码仓库中供全世界 开发者使用，但是由于公司的项目很多不能公开，只可在公司范围使用，又需要在不同项目中可以方便接入，在后续功能修改时 又能通过版本控制 使用修改前后的功能均可正常使用， 这个时候可以 搭建私有 maven 仓库，部署我们的公共组件代码，就可以方便使用了。 使用Nexus搭建 maven 私服下面演示在window上的安装过程 1.下载Nexus下载地址：http://www.sonatype.com/download-oss-sonatype 2.解压zip文件，配置nexus下bin目录全局变量 然后打开我的电脑-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量 在path 中配置 上面的bin 文件夹的路径进去 F:\Downloads\nexus-3.16.1-02-win64\nexus-3.16.1-02\bin 3.安装nexus服务，以管理员身份运行 cmd 进入 上面bin的文件夹下， 运行nexus.exe/install Nexus Service命令查看服务里就能看到 4.启动服务,启动这个服务，稍等一会时间，在浏览器中访问 http://localhost:8081/。就能够看到这个页面 默认的用户名和密码登录（admin/admin123） 目前为止 服务搭建成功。 仓库的详细配置过程，请移步到官方网站http://books.sonatype.com/nexus-book/reference3/admin.html#admin-repositories 下面来看怎么使用的问题； 上传 aar 到我们搭建的私服上 步骤1. Nexus创建自己的仓库访问：http://localhost:8081/nexus，先创建一个你要上传的仓库信息： 点击create repository name那输入你想创建的名称，如 younger然后点创建，就可以看到了自己的仓库 http://10.1.1.147:8081/repository/younger/ （此ip为我自己电脑局域网ip） 2. Android Studio 配置新建一个module，这个module就是你要编译的aarmodule下gradle配置如下，添加代码：apply plugin:’maven’ 和 1234567891011121314151617uploadArchives &#123; configuration = configurations.archives repositories &#123; mavenDeployer &#123; repository(url: 'http://10.1.1.147:8081/repository/younger/') &#123; authentication(userName: 'admin', password: 'admin123') &#125; pom.project &#123; version '0.0.1' artifactId 'testmaven' groupId 'demo.younger.com' packaging 'aar' description 'update version 0.0.1' &#125; &#125; &#125;&#125; groupId，version要注意填好。然后，在Gradle projects列表中可以看到upload的Task点击后即可编译上传，success后就可以了。 可以看到编译成功 ，在Nexus后台可以看到： 3. Android Studio 中引用//添加仓库在根gradle 中添加 1234567891011allprojects &#123; repositories &#123; google() jcenter()//新增 maven &#123; url 'http://10.1.1.147:8081/repository/younger/' &#125; &#125;&#125; 在项目的gradle 中使用1implementation 'demo.younger.com:testmaven:0.0.1' 就可以正常引用了， 可以看到上面的顺序是 groupId ：artifactId： version 也可以在 External Libraries 查看到 项目中也可以引用啦 目前项目中weex就是采用这种方式， 搭建一个nexus 私服，把weex 官方的sdk 下载下来，我们根据项目需要，自行实现很多不同的功能，而这些功能在不同的项目都可以用到，就统一放到私服上，在我们具体的项目中，只需要简单设置，就可以非常方便的使用这些功能，如果新增了什么功能，可以直接把代码上传到公共组件中，升级版本， 项目中用的时候只需要改成相应的版本号就可以方便使用到最新的功能。 总结可以发现，创建私服，上传aar文件， 引用都非常简单， 具体有没有必要使用还是需要根据自身实际情况来看，那些公共仓库上的内容可以优先使用阿里云的代理仓库，这样会加快同步速度，自己内部使用或者比较特殊的内容就可以放到私服上了，同样是特别方便。]]></content>
      <tags>
        <tag>Android私服</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从ARM暂停与华为合作谈起 Android中SO兼容的那些事]]></title>
    <url>%2FAndroid%E4%B8%ADSO%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[因为包含来自美国的技术，ARM（英国）已经要求员工“停止所有与华为及其子公司正在生效的合约、支持及未决约定” 从最近的新闻来看，美国的贸易禁令使得华为公司腹背受敌，ARM彻底暂停与华为合作已成定局，最新款的芯片技术肯定是用不上了，不过华为已经获得了ARMv8的永久授权。但是ARM是什么样的存在？ 为什么对华为有这么大的影响力呢，事实上 ARM处理器 已经一统移动端了。今天就来谈谈 ARM 与 Android SO 的那些事。 背景:公司某项目新上功能部分页面使用 weex 来做的，测试过程中发现 weex 页面在某些手机上出现异常，经过排查定位到是 SO 库的问题，下面是这个问题的解决过程的一个记录，希望能对遇到类似问题的同学提供一些帮助。 什么问题?公司某项目 V1.2.0版本最初上线时，使用的 weex 是官方的 SDK 的接入方式， 接下来 App版本需要把官方的 SDK 替换成我们自己私服上的 SDK（因为私服上有我们针对自己项目需要，自定义了许多控件和公共组件） ，替换后，出现 weex 页面加载异常的问题（白屏） 报错信息如下： 我们注意到，上面有一行错误是 invokeInitFramework java.lang.UnsatisfiedLinkError: 见过该错误的开发者都知道，这个是 JNI 相关的错误信息，根据错误信息能看到是 weex 相关的 JNI 调用出了问题，由JNI 又想到了 SO 库文件， 那就引出今天的话题。 什么是 SO 文件及SO 应用？SO（shared object，共享库）是机器可以直接运行的二进制代码 SO 机制让开发者最大化利用已有的 C 和 C++ 代码，达到复用的效果，利用软件世界积累了几十年的优秀代码； SO 是二进制，没有解释编译的开销，用SO实现的功能比纯java实现的功能要快； SO 内存分配不受 Dalivik/ART 的单个应用限制，减少 OOM； 相对于java代码，二进制代码的反编译难度更大，一些核心代码可以考虑放在 SO 中。 在Android 中 提到 SO 就不能不提 ABI ABI应用程序二进制接口（Application Binary Interface） 定义了其所对应的CPU架构能够执行的二进制文件（特别是.so文件）的格式规范。在 Android 系统上，不同 Android 手机使用不同的 CPU，因此支持不同的指令集。CPU 与指令集的每种组合都有其相应的应用二进制界面（或 ABI）。 ABI 可以非常精确地定义应用的机器代码在运行时如何与系统交互。 您必须为应用要使用的每个 CPU 架构指定 ABI：armeabi，armeabi-v7a，arm64-v8a，x86，x86_64，mips，mips64； 目前 Android 共支持七种不同类型的 CPU 架构，分别是：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起) SO（CPU）的兼容每一个 CPU 架构对应一个 ABI，一个 CPU 属于某一种架构，多核 CPU 属于相同架构才能一起工作，很多设备仅支持一种 CPU 架构。 如果你要完美兼容所有类型的机型，理论上是要在的 libs 目录下放置各个架构平台的 SO 文件。 但项目体积也会变得非常庞大。是否一定需要带入这么多SO文件去兼容呢？答案是否定的。 根据目前Android共支持七种不同类型的CPU架构，其兼容特点可总结如下： armeabi设备只兼容armeabi； armeabi-v7a设备兼容armeabi-v7a、armeabi； arm64-v8a设备兼容arm64-v8a、armeabi-v7a、armeabi； X86设备兼容X86、armeabi； X86_64设备兼容X86_64、X86、armeabi； mips64设备兼容mips64、mips； mips只兼容mips； armeabi 的 SO 文件基本上可以说是兼容目前市面上的大部分手机，它能运行在除了mips和mips64的设备上，但在非 armeabi 设备上运行性能会有所损耗； 64位的CPU架构总能向下兼容其对应的32位指令集，如：x86_64兼容X86，arm64-v8a兼容armeabi-v7a，mips64兼容mips； 总结成一句话就是， 新的CPU 架构总能向下兼容； 所以知道这些信息后，查看公司其他项目怎么用的, 发现其他项目, 在 build.gradle 中关于 ndk.abiFilters 都是这样写的： 而这个项目的写法是这样的： 区别就是这个 ndk.abiFilters ， 既然这样写，必定有它的原因， 那就继续找，为什么要这么写，咨询相关的同事，了解到相关路径下的文件是 视频聊天、语音相关的 SO 库。 那能不能改成只支持 armeabi 或者 他们其中的部分呢。那就模拟这些情况，然后分别打出了这么多包（包的命名有点随意，这不是重点），分别在不同的手机上验证是否能正常加载 weex 。 经测试发现 armeabi 的和 armeabi +x86 的都可以正常加载 weex 页面，感觉问题这么简单就解决了，但是！！！ 想到去掉这么多东西 会不会影响其他正常功能呢， 那就验证下吧，试了下视频相关功能，果不其然的 app 崩溃了。 说明上面的方向肯定是有问题，使用工具 Native libs Monitor 查看下Apk 中具体的SO 文件 首先查看下那些我们常用的App 是怎么做的，微信、QQ、支付宝等等 其他公司如何适配的 微信（只适配armeabi，有少量 v7a）； qq（只适配armeabi，文件夹下有少量x86）； 百度地图（只适配armeabi）； 大众点评（只适配armeabi）； google 家 （基本都是 arm64）； 支付宝 （基本都是 armeabi 的，2个x86的）； 而且 公司别的项目App 中 用到的 face++ 的人脸识别，身份证识别 也是只提供了armeabi 的SO 文件 下图是微信的Apk 解压出的情况， 微信的lib下虽然只有armeabi-v7a一个目录，但目录内的文件仍放着v7a和 armeabi架构的SO文件，用于处理兼容带来的某些性能运算问题。 看完大公司的适配情况，然后看下我们自己 公司这几个项目，看看到底有什么区别， 还有上面打出的不同的包，相应的 SO 引入情况。 经过对比发现， 指定不同的 abi 会 在apk 中 打入相应 的文件(前提是 你有这些文件)，这就是一个过滤器，只在包中引入指定的cpu 架构的 SO 文件。 既然重点是 weex 加载的出了问题，然后就重点查看 weex 相关的 SO 引入情况， 既然官方的可以正常使用， 我们私服上却出了问题，然后对比使用官方的 sdk 集成方式,和我们私服上的集成方式的 SO 库有什么不同； 如图是集成weex 官方sdk 的 APK 而集成私服上的 sdk 后，只在 armv5中有 libweexjsc.so 而 armv7 中是没有这个问题的。 区别找到了，那就去私服的项目中找原因 并没有 armeabi-v7a 的文件，相应的 lib下也没有相应的文件夹和文件，按照一样的写法，在这加入 armeabi-v7a 相应的路径，相应的 lib 下，也新建了相应的文件夹，放入相应的文件。重新编译 再次尝试, 查看 lib 在 arm v7 和 v8a 的手机上,查看 lib 情况,发现, 在都能看到相应的 SO 文件了, 多部手机尝试， 视频聊天、语音、 weex 都正常、至此 问题得到解决。 在排查问题的过程中发现，其实这个项目 本来的 build.gradle 文件中的 arm64-v8a 写错了，以前写成了 armeabi-v8a 其实这样是无法使用到 arm64-v8a下的 so 的。 但是会向下兼容, 使用了 armeabi-v7a 中的文件，也没有报错，其实也是因祸得福，如果写正确的话，weex 在 arm64-v8a 也会加载失败，因为 官方也没有提供这样的一个文件夹和文件。 但是我们要怎么配置呢？ 从目前移动端CPU市场的份额数据看，ARM架构几乎垄断，所以，除非你的用户很特殊，否则几乎可以不考虑单独编译带入X86、X86_64、mips、mips64架构SO文件。除去这四个架构之后，还要带入armeabi、armeabi-v7a、arm64-v8a 这三个不同类型，这对于一个拥有大量SO文件的应用来说，安装包的体积将会增大不少。 针对不同平台，如何去适配，如何抉择目前主流的Android设备主要是 armeabi-v7a ARMv8 架构的，程序在运行的时候去加载不同平台对应的so，这是较为完美的一种解决方案，但是有时候为了减少包体积的大小， 不会同时设置 armeabi， armeabi-v7a 和 x86。根据不同的情况，可以进行不同的适配， 1.只适配 armeabi-v7a，因为目前主流机型是 ARMv7，并且 ARMv8 设备也向下兼容了armeabi-v7a， Facebook、WhatsApp、王者荣耀等就是只适配了armeabi-v7a。（Google play store下载 Native libs Monitor 进行查看）。 2.只适配 armeabi，因为 ARMv7 、ARMv8 还是 x86 都兼容 armeabi，但是性能都会有些损耗，例如ARMv7 支持硬件浮点运算等没法体现，x86 支持 armeabi 同样具有相应的损耗。 3.同时适配 armeabi-v7a 和 armeabi，既能够支持所有 ARM 架构，同时又能具有 ARMv7 支持硬件浮点运算等特性，例如Line等应用。 4.同时适配 x86 和 armeabi，既能支持所有 ARM 架构，又能支持x86架构，唯一的缺点就是没有了ARMv7 支持硬件浮点运算等一系列特性，例如QQ。 5.同时适配 armeabi， armeabi-v7a 和 x86，在性能方面来说是较为完美的方案，只是APK的大小也会随之变大。 6.还有其他的一些方案，例如微信只适配了armeabi，但是对于某些需要利用 ARMv7 支持硬件浮点运算等一系列特性的操作，在armeabi目录下存在v7对应的so文件，通过代码判断加载不同的so文件。即达到了减少APK大小的目的，又能达到适配ARMv7等架构以便使用其架构的一些新特性的目的。 就目前市场份额而言，绝大部分的设备都已经是armeabi-v7a、arm64-v8a，可以考虑只保留armeabi-v7a架构的SO文件，这样能获得更好的性能效果。所以我们的 这个项目选择采用第3种方案； 现在把这个项目中的 ndk.abiFilters 配置成上图所示，几乎覆盖所有机型，weex 能够正常加载，暂时没有发现影响其他功能，这个问题也算是得到解决。在不影响太多性能的情况下，也可以明显减少包的体积。 总结下常见的 引入.so文件的错误1.使用android高版本平台版本编译的.so文件运行在android低版本的设备上使用NDK时，你可能会倾向于使用最新的编译平台，但事实上这是错误的，因为NDK平台不是向下兼容的，而是向上兼容的。推荐使用app的minSdkVersion对应的编译平台。 这也意味着当你引入一个预编译好的.so文件时，你需要检查它编译时所用的平台版本。 2.没有为每个支持的CPU架构提供对应的.so文件arm64-v8a是可以向下兼容的，但前提是你的项目里面没有arm64-v8a的文件夹，如果你有两个文件夹armeabi和arm64-v8a，两个文件夹，armeabi里面有a.so 和 b.so,arm64-v8a里面只有a.so， 那么arm64-v8a的手机在用到b的时候发现有arm64-v8a的文件夹，发现里面没有b.so，就报错了， 所以这个时候删掉arm64-v8a文件夹，这个时候手机发现没有适配arm64-v8a，就会直接去找armeabi的so库，或者把 arm64-v8a文件夹 的 b.so补齐。 参考文章：https://zhuanlan.zhihu.com/p/21302804 https://www.zhihu.com/question/36893314/answer/78467097 https://blog.csdn.net/zophar_development/article/details/84329054 https://www.cnblogs.com/janehlp/p/7473240.html https://www.jianshu.com/p/cb05698a1968 https://www.jianshu.com/p/cb15ba69fa89 等]]></content>
      <tags>
        <tag>Android SO兼容</tag>
        <tag>SO</tag>
        <tag>华为</tag>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我]]></title>
    <url>%2F%E5%85%B3%E4%BA%8E%E6%88%91.html</url>
    <content type="text"><![CDATA[关于我的一些事我是15年本科毕业，2015年9月开始 目前一直从事Android开发, 坐标北京；开发技能 ： Android ，Weex ，Kotlin本科不是 CS 专业，也算是半路出家，一路磕磕绊绊，到现在算是一个基本合格的API Player。对计算机底层，数据结构、算法等这些难啃的骨头，心底感觉到畏惧，感觉太难了，心底有点怕。 但是 我认为 &lt;数据结构和算法&gt; 是一个合格的程序员的必要的基础知识,这个会让帮助更好设计程序, 知道怎么用,也知道为什么要这么用，这样才能有更长久的发展；看过的计算机书籍： 《第一行代码》 《Android群英传》 《Android开发艺术探索》 《Android进阶之光》 《Android高级进阶》 《大话数据结构》 订阅的专栏： 《小专栏》 《数据结构和算法之美》 《Android开发高手课》 《左耳听风》 还有好多大神的技术博客， 但是技术这个东西，如果不能经常使用，会比较容易忘，需要多动手去实践，最好是将自己学到的知识，用自己的语言讲述一遍出来，实践后写出来，这样会记得比较牢，有条件的可以在小组，公司或者更大范围分享出来，大家一起讨论，这样会加深记忆。 建立这个博客其实也是希望自己能分享出点什么内容，API Player 太没有水平了， 不能止步于此吧，一个技术人要有技术追求。在大环境不太好的情况下，沉下心来，丰富自己，多学习，多输出，才能在寒冬中让自己走的更稳。共勉吧，朋友们。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开站顺利]]></title>
    <url>%2F%E5%BC%80%E7%AB%99%E9%A1%BA%E5%88%A9.html</url>
    <content type="text"><![CDATA[这是Younger 的第一篇内容终于我也有自己的个人网站了 昨天是周日,下午开始弄这个,申请域名, 搭建网站,整个过程真的好简单,以前一直以为很难的,就一直没有动手的去弄; 目前来看, 困难都是自己想象出来的, 真正动手去做,就会发现,也没有那么难,真正需要做的就是行动, 勇敢踏出第一步 购买域名域名是在 namesilo 买的, 用了优惠码后一年也就是不到50元,支持支付宝支付,方便至极 ,如果有需要可以寻找网上的优惠码, 可以节省1美元, 我这个域名买下来一年5.99美元,也就是不到45块钱,可谓是相当的划算了. 关于域名商的选择我也是查了下资料, 之所以没有选择国内的服务商, 主要是众所周知的原因, 国内的需要备案, 且你的域名随时可能被关掉等不安全因素, 还是在国际知名的大的域名商买比较靠谱, namesilo 这个打的广告比较少, 说是让利给消费者, 的确是很便宜, 我是对比了多家, 发现这家便宜的, 还有 namecheap 也比较便宜. 这个还是见仁见智了, 想买哪个都行, 续费便宜, 服务好就行. 主机使用的是 github.io + hexo 搭建的,过程非常的简单, 感谢各位大佬的教程 hexo官网的文档 也很详细,还有视频教程,另外还有好多主题供选择; 傻瓜式安装.每一步都有详细的教程, 然后就成了我现在弄的这个样子, 后续我肯定还会继续更新的. 今天简单弄了一下,记录一下, 虽然用的也都是别人的轮子,但还是很开心呀!]]></content>
      <tags>
        <tag>网站搭建</tag>
        <tag>域名购买</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>namesilo</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Volley 源码解析]]></title>
    <url>%2FVolley-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html</url>
    <content type="text"><![CDATA[Volley 源码解析开始之前目前已经有很多文章写volley源码解析的了， 为什么这么多呢？ 可能是因为volley 的源码相对来说比较少， 逻辑相对简单，好读。 为什么我还要写volley源码解析呢？ 和上面的问题的原因一样， 还有就是我也读了好几遍volley的源码了，每次读完后过段时间就会忘记一些，应了那句老话，“好记性不如烂笔头”，现在也不用纸笔了，直接电脑上敲出来，更方便。 我不一定写的比其他同学的高明，但是我会尽量写出我的理解，和现实工作内容联系起来书写。 注意本文是基于volley最新版本 1.1版本源码 本文的目录结构是： volley 的基本使用 volley 源码解析 volley 的优缺点 volley 的扩展 volley 基本使用Volley 是 Google 推出的 Android 异步网络请求框架和图片加载框架。在 Google I/O 2013 大会上发布。 特别适合数据量小，通信频繁的网络操作 12345在项目的gradle 文件中添加依赖dependencies &#123; ... implementation 'com.android.volley:volley:1.1.1'&#125; 使用起来很简单，举一个StringRequest例子，其他的类似 12345678910111213141516171819//构建一个请求队列RequestQueue queue = Volley.newRequestQueue(this); String url ="http://www.baidu.com";//创建一个request StringRequest stringRequest = new StringRequest(com.android.volley.Request.Method.GET,url, new com.android.volley.Response.Listener&lt;String&gt;() &#123; @Override public void onResponse(String response) &#123; &#125; &#125;, new com.android.volley.Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; &#125; &#125;);//把request 添加到 队列中 queue.add(stringRequest); [图片] volley 源码解析首先我们看下请求队列的创建。 Volley1RequestQueue queue = Volley.newRequestQueue(this); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 public static RequestQueue newRequestQueue(Context context) &#123; return newRequestQueue(context, (BaseHttpStack) null); &#125;重载 newRequestQueue 方法 public static RequestQueue newRequestQueue(Context context, BaseHttpStack stack) &#123; BasicNetwork network; if (stack == null) &#123; if (Build.VERSION.SDK_INT &gt;= 9) &#123; network = new BasicNetwork(new HurlStack()); &#125; else &#123; String userAgent = "volley/0"; try &#123; String packageName = context.getPackageName(); PackageInfo info = context.getPackageManager().getPackageInfo(packageName, /* flags= */ 0); userAgent = packageName + "/" + info.versionCode; &#125; catch (NameNotFoundException e) &#123; &#125; network = new BasicNetwork( new HttpClientStack(AndroidHttpClient.newInstance(userAgent))); &#125; &#125; else &#123; network = new BasicNetwork(stack); &#125; return newRequestQueue(context, network); &#125; 最终调用这个方法start private static RequestQueue newRequestQueue(Context context, Network network) &#123; //创建缓存目录 File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR); //创建任务队列 RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network); //启动队列 queue.start(); return queue; &#125; 先判断是否有指定 stack 也就是实际请求的方式，如果有传进来，就用传的来指定的方式，如果为空， 就按照sdk 版本创建相应的请求方式， sdk版本&lt;9的使用 httpClient 请求 大于等于9的使用 httpUrlconnection 来请求，这是因为，httpUrlconnection在Android 2.2之前有bug。但是httpClient 没有 httpUrlconnection 性能好， Api简单，体积较小，压缩和缓存机制也可有效减少网络访问的流量， 而且httpclient 请求的方式 在Android6.0之后也直接从sdk 中直接去掉了。 RequestQueue1234567public RequestQueue(Cache cache, Network network, int threadPoolSize) &#123; this( cache, network, threadPoolSize, new ExecutorDelivery(new Handler(Looper.getMainLooper()))); &#125; 可以重点关注 ExecutorDelivery(new Handler(Looper.getMainLooper())))接下来在线程切换地方法讲到它，这个是成功把子线程数据发送到主线程的关键 123456789101112131415161718任务队列的启动方法 /** Starts the dispatchers in this queue. */ public void start() &#123; stop(); // Make sure any currently running dispatchers are stopped. // Create the cache dispatcher and start it. //创建了一个缓存调度线程 并启动 mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery); mCacheDispatcher.start(); // Create network dispatchers (and corresponding threads) up to the pool size. //创建了4个网络调度线程，并启动 for (int i = 0; i &lt; mDispatchers.length; i++) &#123; NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery); mDispatchers[i] = networkDispatcher; networkDispatcher.start(); &#125; &#125; 任务队列创建完成，等到request 加入，request的创建比较简单，可以根据自己的需求创建相应的request ，系统提供了 String ，Image， JsonObject ，jsonArray 等request，他们的区别主要是在 parseNetworkResponse 方法中根据不同的数据类型，进行相应数据类型的解析。 再看网络请求的 add 方法，就是把request 添加到 任务队列中 1234567891011121314151617181920public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) &#123; // Tag the request as belonging to this queue and add it to the set of current requests. request.setRequestQueue(this); synchronized (mCurrentRequests) &#123; mCurrentRequests.add(request); &#125; // Process requests in the order they are added. request.setSequence(getSequenceNumber()); request.addMarker("add-to-queue"); // 判断这个 request 是否支持缓存, 如果不支持就直接 把这个request加入到网络调度线程中 //否则就加入到缓存 调度线程。 if (!request.shouldCache()) &#123; mNetworkQueue.add(request); return request; &#125; mCacheQueue.add(request); return request;&#125; 这个 mNetworkQueue 和 mCacheQueue 都是 PriorityBlockingQueue 优先级阻塞队列 现在根据情况分别加入到相应的调度线程等待执行 CacheDispatcher上面已经把request加入到缓存队列中了，接下来看下 CacheDispatcher 是如何处理这些request的。 1234public class CacheDispatcher extends Thread &#123;...&#125; 能看到这个 CacheDispatcher 继承 Thread ，前面我们也看到start 方法中已经 调用了线程的 start（） ，那我们看下run方法 123456789101112131415161718192021222324@Override public void run() &#123; if (DEBUG) VolleyLog.v("start new dispatcher"); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); // Make a blocking call to initialize the cache. mCache.initialize(); while (true) &#123; try &#123; processRequest(); &#125; catch (InterruptedException e) &#123; // We may have been interrupted because it was time to quit. if (mQuit) &#123; Thread.currentThread().interrupt(); return; &#125; VolleyLog.e( "Ignoring spurious interrupt of CacheDispatcher thread; " + "use quit() to terminate it"); &#125; &#125; &#125; 能看到代码相当简洁， 就是一个 while (true) 死循环， 里面执行 processRequest方法， 123456private void processRequest() throws InterruptedException &#123; // Get a request from the cache triage queue, blocking until // at least one is available. final Request&lt;?&gt; request = mCacheQueue.take(); processRequest(request);&#125; 英文注释写的也特别清楚，就是从 BlockingQueue阻塞队列中取出，如果有数据就处理，没有数据就阻塞在这。 BlockingQueue如果BlockQueue是空的，从BlockingQueue取东西的操作将会被阻断进入等待状态，直到BlockingQueue进了东西才会被唤醒。 同样，如果BlockingQueue是满的，任何试图往里存东西的操作也会被阻断进入等待状态，直到BlockingQueue里有空间才会被唤醒继续操作。 了解了 BlockingQueue 我们看下真正处理request的详细方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273void processRequest(final Request&lt;?&gt; request) throws InterruptedException &#123; request.addMarker("cache-queue-take"); // 先判断这个request是否已经被取消，需求就不继续了，直接调用finish 方法 if (request.isCanceled()) &#123; request.finish("cache-discard-canceled"); return; &#125; // 尝试从缓存中查找是否有同样的request在 Cache.Entry entry = mCache.get(request.getCacheKey()); if (entry == null) &#123; request.addMarker("cache-miss"); // 如果没有缓存，就加入到网络请求的队列 if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123; mNetworkQueue.put(request); &#125; return; &#125; //如果缓存已经过期，也加入到网络请求的队列 if (entry.isExpired()) &#123; request.addMarker("cache-hit-expired"); request.setCacheEntry(entry); if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123; mNetworkQueue.put(request); &#125; return; &#125; // 在缓存中找到了这个请求，且没有过期，把 服务端返回的数据解析后取出，传回。 request.addMarker("cache-hit"); Response&lt;?&gt; response = request.parseNetworkResponse( new NetworkResponse(entry.data, entry.responseHeaders)); request.addMarker("cache-hit-parsed"); if (!entry.refreshNeeded()) &#123; // 直接发送 mDelivery.postResponse(request, response); &#125; else &#123; // 发送缓存的同时 也把request加入到网络请求线程，刷新数据 request.addMarker("cache-hit-refresh-needed"); request.setCacheEntry(entry); // Mark the response as intermediate. response.intermediate = true; if (!mWaitingRequestManager.maybeAddToWaitingRequests(request)) &#123; // Post the intermediate response back to the user and have // the delivery then forward the request along to the network. mDelivery.postResponse( request, response, new Runnable() &#123; @Override public void run() &#123; try &#123; mNetworkQueue.put(request); &#125; catch (InterruptedException e) &#123; // Restore the interrupted status Thread.currentThread().interrupt(); &#125; &#125; &#125;); &#125; else &#123; // request has been added to list of waiting requests // to receive the network response from the first request once it returns. mDelivery.postResponse(request, response); &#125; &#125; &#125; NetworkDispatcher看完了 缓存队列的执行方式， 再看下网络请求线程的执行，跟上面的方法方式类似，我们直奔processRequest看它是如何实现的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void processRequest(Request&lt;?&gt; request) &#123; long startTimeMs = SystemClock.elapsedRealtime(); try &#123; request.addMarker("network-queue-take"); // 是否取消，取消的话就结束 if (request.isCanceled()) &#123; request.finish("network-discard-cancelled"); request.notifyListenerResponseNotUsable(); return; &#125; addTrafficStatsTag(request); // 进行网络请求， performRequest 这个方法中是具体的网络请求的内容 NetworkResponse networkResponse = mNetwork.performRequest(request); request.addMarker("network-http-complete"); // 如果返回304 同时已经回传过了返回值，就不再回传内容了，结束 if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123; request.finish("not-modified"); request.notifyListenerResponseNotUsable(); return; &#125; // 在工作线程中解析返回内容 Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse); request.addMarker("network-parse-complete"); //如果需要缓存， 就把内容放到缓存中 if (request.shouldCache() &amp;&amp; response.cacheEntry != null) &#123; mCache.put(request.getCacheKey(), response.cacheEntry); request.addMarker("network-cache-written"); &#125; // 把解析出的内容回传。 request.markDelivered(); mDelivery.postResponse(request, response); request.notifyListenerResponseReceived(response); &#125; catch (VolleyError volleyError) &#123; volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs); parseAndDeliverNetworkError(request, volleyError); request.notifyListenerResponseNotUsable(); &#125; catch (Exception e) &#123; VolleyLog.e(e, "Unhandled exception %s", e.toString()); VolleyError volleyError = new VolleyError(e); volleyError.setNetworkTimeMs(SystemClock.elapsedRealtime() - startTimeMs); mDelivery.postError(request, volleyError); request.notifyListenerResponseNotUsable(); &#125; &#125; 具体执行网络请求的是 BasicNetwork 的 performRequest 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public NetworkResponse performRequest(Request&lt;?&gt; request) throws VolleyError &#123; long requestStart = SystemClock.elapsedRealtime(); while (true) &#123; HttpResponse httpResponse = null; byte[] responseContents = null; List&lt;Header&gt; responseHeaders = Collections.emptyList(); try &#123; // 把所有的header 信息拿到 Map&lt;String, String&gt; additionalRequestHeaders = getCacheHeaders(request.getCacheEntry()); // 具体的根据不同的情况，看Android SDK 版本号 是否小于9 来选择使用 // httpClient 还是httpUrlconnection 进行创建网络链接 httpResponse = mBaseHttpStack.executeRequest(request, additionalRequestHeaders); int statusCode = httpResponse.getStatusCode(); responseHeaders = httpResponse.getHeaders(); // 处理304问题 if (statusCode == HttpURLConnection.HTTP_NOT_MODIFIED) &#123; Entry entry = request.getCacheEntry(); if (entry == null) &#123; return new NetworkResponse( HttpURLConnection.HTTP_NOT_MODIFIED, /* data= */ null, /* notModified= */ true, SystemClock.elapsedRealtime() - requestStart, responseHeaders); &#125; // Combine cached and response headers so the response will be complete. List&lt;Header&gt; combinedHeaders = combineHeaders(responseHeaders, entry); return new NetworkResponse( HttpURLConnection.HTTP_NOT_MODIFIED, entry.data, /* notModified= */ true, SystemClock.elapsedRealtime() - requestStart, combinedHeaders); &#125; // 处理异常情况 InputStream inputStream = httpResponse.getContent(); if (inputStream != null) &#123; responseContents = inputStreamToBytes(inputStream, httpResponse.getContentLength()); &#125; else &#123; // Add 0 byte response as a way of honestly representing a // no-content request. responseContents = new byte[0]; &#125; // if the request is slow, log it. long requestLifetime = SystemClock.elapsedRealtime() - requestStart; logSlowRequests(requestLifetime, request, responseContents, statusCode); if (statusCode &lt; 200 || statusCode &gt; 299) &#123; throw new IOException(); &#125; //最后new 了一个NetworkResponse 把返回的内容包装后返回前一个方法，继续处理 return new NetworkResponse( statusCode, responseContents, /* notModified= */ false, SystemClock.elapsedRealtime() - requestStart, responseHeaders); &#125; catch (SocketTimeoutException e) &#123; //重试机制 attemptRetryOnException("socket", request, new TimeoutError()); &#125; catch (MalformedURLException e) &#123; throw new RuntimeException("Bad URL " + request.getUrl(), e); &#125; catch (IOException e) &#123; int statusCode; if (httpResponse != null) &#123; statusCode = httpResponse.getStatusCode(); &#125; else &#123; throw new NoConnectionError(e); &#125; VolleyLog.e("Unexpected response code %d for %s", statusCode, request.getUrl()); NetworkResponse networkResponse; if (responseContents != null) &#123; networkResponse = new NetworkResponse( statusCode, responseContents, /* notModified= */ false, SystemClock.elapsedRealtime() - requestStart, responseHeaders); if (statusCode == HttpURLConnection.HTTP_UNAUTHORIZED || statusCode == HttpURLConnection.HTTP_FORBIDDEN) &#123; //重试机制 attemptRetryOnException( "auth", request, new AuthFailureError(networkResponse)); &#125; else if (statusCode &gt;= 400 &amp;&amp; statusCode &lt;= 499) &#123; // Don't retry other client errors. throw new ClientError(networkResponse); &#125; else if (statusCode &gt;= 500 &amp;&amp; statusCode &lt;= 599) &#123; if (request.shouldRetryServerErrors()) &#123; attemptRetryOnException( "server", request, new ServerError(networkResponse)); &#125; else &#123; throw new ServerError(networkResponse); &#125; &#125; else &#123; // 3xx? No reason to retry. throw new ServerError(networkResponse); &#125; &#125; else &#123; //重试机制 attemptRetryOnException("network", request, new NetworkError()); &#125; &#125; &#125;&#125; HurlStack我们可以再看下建立网络链接的部分，这个是httpUrlcinnection， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Overridepublic HttpResponse executeRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders) throws IOException, AuthFailureError &#123; String url = request.getUrl(); HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.putAll(additionalHeaders); // Request.getHeaders() takes precedence over the given additional (cache) headers). map.putAll(request.getHeaders()); if (mUrlRewriter != null) &#123; String rewritten = mUrlRewriter.rewriteUrl(url); if (rewritten == null) &#123; throw new IOException("URL blocked by rewriter: " + url); &#125; url = rewritten; &#125; URL parsedUrl = new URL(url); HttpURLConnection connection = openConnection(parsedUrl, request); boolean keepConnectionOpen = false; try &#123; for (String headerName : map.keySet()) &#123; connection.setRequestProperty(headerName, map.get(headerName)); &#125; setConnectionParametersForRequest(connection, request); // Initialize HttpResponse with data from the HttpURLConnection. int responseCode = connection.getResponseCode(); if (responseCode == -1) &#123; // -1 is returned by getResponseCode() if the response code could not be retrieved. // Signal to the caller that something was wrong with the connection. throw new IOException("Could not retrieve response code from HttpUrlConnection."); &#125; if (!hasResponseBody(request.getMethod(), responseCode)) &#123; return new HttpResponse(responseCode, convertHeaders(connection.getHeaderFields())); &#125; // Need to keep the connection open until the stream is consumed by the caller. Wrap the // stream such that close() will disconnect the connection. keepConnectionOpen = true; return new HttpResponse( responseCode, convertHeaders(connection.getHeaderFields()), connection.getContentLength(), new UrlConnectionInputStream(connection)); &#125; finally &#123; if (!keepConnectionOpen) &#123; connection.disconnect(); &#125; &#125;&#125; 总结上面这个方法就是 把所有的请求头信息发送出去，如果有请求体，把请求体也发送过去， 等待服务端相应，响应后把返回值回传到上一个方法中处理。 volley 是如何实现线程切换的 主线程上开启子线程执行网络请求在上面分析中能看到。 创建了1个缓存线程，4个网络请求线程，执行相应的网络请求。 子线程在处理完耗时操作，处理完数据，怎么发送到主线程的呢？ ExecutorDelivery接下来看下我们上面多次看到的 mDelivery.postResponse(request, response); 是怎么处理的 先看下构造方法 1234567891011121314151617181920 public ExecutorDelivery(final Handler handler) &#123; //注意这个 Handler 这是RequestQueue 构造方法中初始化的，传入的是 Looper.getMainLooper()， 它就是主线程的handler //创建了一个线程池，它的作用就是在线程中调用 handler，发送 runnable，通过这种形式使得 runnable 在 UI 线程中执行。 mResponsePoster = new Executor() &#123; @Override public void execute(Runnable command) &#123; handler.post(command); &#125; &#125;; &#125;//看下具体方法 @Override public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) &#123; request.markDelivered(); request.addMarker("post-response"); mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable)); &#125; 通过这种方式，mResponsePoster.execute 是得里面的runnable能够在主线程中得到执行， ResponseDeliveryRunnable1234567891011121314151617181920212223242526 // If this request has canceled, finish it and don't deliver. if (mRequest.isCanceled()) &#123; mRequest.finish("canceled-at-delivery"); return; &#125; // Deliver a normal response or error, depending. if (mResponse.isSuccess()) &#123; mRequest.deliverResponse(mResponse.result); &#125; else &#123; mRequest.deliverError(mResponse.error); &#125; // If this is an intermediate response, add a marker, otherwise we're done // and the request can be finished. if (mResponse.intermediate) &#123; mRequest.addMarker("intermediate-response"); &#125; else &#123; mRequest.finish("done"); &#125; // 发送之后，都会调用 Runnable 的 run() ，这个已经可执行的 Runnable 已经切换到主线程了。 if (mRunnable != null) &#123; mRunnable.run(); &#125;&#125; 最后调用 request 的 finish 方法，表示该请求已经执行结束了，同时，如果 ResponseDeliveryRunnable 的构造方法中的第三个参数 runnable 不为空，立即执行该 runnable 的 run 方法。 再看这个Stringrequest中的 1234567891011@Overrideprotected void deliverResponse(String response) &#123; Response.Listener&lt;String&gt; listener; synchronized (mLock) &#123; listener = mListener; &#125; if (listener != null) &#123; listener.onResponse(response); &#125;&#125; 在主线程 通过接口回调，回调到发起请求的位置，进行相应的处理。 volley 的优缺点优点： 特别适合数据量小，通信频繁的网络操作 轻量，jar包相对较小 扩展性强。Volley 中大多是基于接口的设计，可配置性强。 一定程度符合 Http 规范，包括返回 ResponseCode(2xx、3xx、4xx、5xx）的处理，请求头的处理，缓存机制的支持等。并支持重试及优先级定义。 默认 Android2.3 及以上基于 HttpURLConnection，2.3 以下基于 HttpClient 实现， 提供简便的图片加载工具。 网络请求线程NetworkDispatcher默认开启了4个，可以优化，通过手机CPU数量 缺点： 在BasicNetwork中判断了statusCode(statusCode &lt; 200 || statusCode &gt; 299)，如何符合条件直接抛出IOException()，不够合理。 图片加载性能一般 导致401等其他状态抛出IOException 对大文件下载 Volley的表现非常糟糕 使用的是httpclient，HttpURLConnection。不过在android 6.0不支持httpclient了，如果想支持得添加org.apache.http.legacy.jar 为什么volley 不适合下载上传大文件？为什么适合数据量小的频率高的请求？ Volley的网络请求线程池默认大小为4。意味着可以并发进行4个请求，大于4个，会排在队列中。 Volley将整个response加载到内存并进行操作（可以是解析等操作）大文件可能会引起OOM volley 的扩展有时候我们整个项目在使用的volley 如果要替换成okhttp 的成本就比较高了， 那能不能方便简单的时候okhttp 的优秀的功能呢， 答案当然是可以的。 还记得这个吗？ 最开始分析源码时， 12345678910111213141516171819202122232425262728293031public static RequestQueue newRequestQueue(Context context, BaseHttpStack stack) &#123; BasicNetwork network; if (stack == null) &#123; if (Build.VERSION.SDK_INT &gt;= 9) &#123; network = new BasicNetwork(new HurlStack()); &#125; else &#123; // Prior to Gingerbread, HttpUrlConnection was unreliable. // See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html // At some point in the future we'll move our minSdkVersion past Froyo and can // delete this fallback (along with all Apache HTTP code). String userAgent = "volley/0"; try &#123; String packageName = context.getPackageName(); PackageInfo info = context.getPackageManager().getPackageInfo(packageName, /* flags= */ 0); userAgent = packageName + "/" + info.versionCode; &#125; catch (NameNotFoundException e) &#123; &#125; network = new BasicNetwork( new HttpClientStack(AndroidHttpClient.newInstance(userAgent))); &#125; &#125; else &#123; network = new BasicNetwork(stack); &#125; return newRequestQueue(context, network);&#125; 如果我们传stack 进来，这个 stack 就是null 了，所以，我们只需要实现这个HttpStack 然后传进来就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145public class OkHttpStack implements HttpStack &#123; private final OkHttpClient mClient;//提供一个构造函数，传入OkHttpClient 对象 public OkHttpStack(OkHttpClient client) &#123; this.mClient = client; &#125; private static HttpEntity entityFromOkHttpResponse(Response response) throws IOException &#123; BasicHttpEntity entity = new BasicHttpEntity(); ResponseBody body = response.body(); entity.setContent(body.byteStream()); entity.setContentLength(body.contentLength()); entity.setContentEncoding(response.header("Content-Encoding")); if (body.contentType() != null) &#123; entity.setContentType(body.contentType().type()); &#125; return entity; &#125;//请求方法和请求体 @SuppressWarnings("deprecation") private static void setConnectionParametersForRequest (okhttp3.Request.Builder builder, Request&lt;?&gt; request) throws IOException, AuthFailureError &#123; switch (request.getMethod()) &#123; case Request.Method.DEPRECATED_GET_OR_POST: byte[] postBody = request.getPostBody(); if (postBody != null) &#123; builder.post(RequestBody.create (MediaType.parse(request.getPostBodyContentType()), postBody)); &#125; break; case Request.Method.GET: builder.get(); break; case Request.Method.DELETE: builder.delete(); break; case Request.Method.POST: builder.post(createRequestBody(request)); break; case Request.Method.PUT: builder.put(createRequestBody(request)); break; case Request.Method.HEAD: builder.head(); break; case Request.Method.OPTIONS: builder.method("OPTIONS", null); break; case Request.Method.TRACE: builder.method("TRACE", null); break; case Request.Method.PATCH: builder.patch(createRequestBody(request)); break; default: throw new IllegalStateException("Unknown method type."); &#125; &#125; private static RequestBody createRequestBody(Request request) throws AuthFailureError &#123; final byte[] body = request.getBody(); if (body == null) return null; return RequestBody.create(MediaType.parse(request.getBodyContentType()), body); &#125; private static ProtocolVersion parseProtocol(final Protocol protocol) &#123; switch (protocol) &#123; case HTTP_1_0: return new ProtocolVersion("HTTP", 1, 0); case HTTP_1_1: return new ProtocolVersion("HTTP", 1, 1); case SPDY_3: return new ProtocolVersion("SPDY", 3, 1); case HTTP_2: return new ProtocolVersion("HTTP", 2, 0); &#125; throw new IllegalAccessError("Unkwown protocol"); &#125;//performRequest方法,首先我们设置一下超时时间 @Override public HttpResponse performRequest(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders) throws IOException, AuthFailureError &#123; int timeoutMs = request.getTimeoutMs(); OkHttpClient client = mClient.newBuilder() .readTimeout(timeoutMs, TimeUnit.MILLISECONDS) .connectTimeout(timeoutMs, TimeUnit.MILLISECONDS) .writeTimeout(timeoutMs, TimeUnit.MILLISECONDS) .build(); okhttp3.Request.Builder okHttpRequestBuilder = new okhttp3.Request.Builder(); //设置请求头，请求头的来源有两个 Map&lt;String, String&gt; headers = request.getHeaders(); for (final String name : headers.keySet()) &#123; okHttpRequestBuilder.addHeader(name, headers.get(name)); &#125; for (final String name : additionalHeaders.keySet()) &#123; okHttpRequestBuilder.addHeader(name, additionalHeaders.get(name)); &#125; setConnectionParametersForRequest(okHttpRequestBuilder, request); okhttp3.Request okhttp3Request = okHttpRequestBuilder.url(request.getUrl()).build(); //开始请求 Response okHttpResponse = client.newCall(okhttp3Request).execute(); StatusLine responseStatus = new BasicStatusLine ( parseProtocol(okHttpResponse.protocol()), okHttpResponse.code(), okHttpResponse.message() ); BasicHttpResponse response = new BasicHttpResponse(responseStatus); response.setEntity(entityFromOkHttpResponse(okHttpResponse)); Headers responseHeaders = okHttpResponse.headers(); for (int i = 0, len = responseHeaders.size(); i &lt; len; i++) &#123; final String name = responseHeaders.name(i), value = responseHeaders.value(i); if (name != null) &#123; response.addHeader(new BasicHeader(name, value)); &#125; &#125;//最后返回HttpResponse对象 return response; &#125;&#125; 总结总体来看，volley 源码还是比较简单的，结构清晰，代码量少，对于想读源码的同学还是一个比较不错的选择。有兴趣的可以尝试下。 也希望看这篇文章的同学能从本文中受益，也欢迎与我交流学习。 下一篇是分析 okHttp 的源码，敬请期待。]]></content>
      <tags>
        <tag>volley</tag>
        <tag>源码</tag>
        <tag>网络请求</tag>
        <tag>Android网络</tag>
        <tag>volley扩展</tag>
        <tag>volley优缺点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基础知识]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    <content type="text"><![CDATA[计划写两篇关于 解析 Volley源码 和 Okhttp源码的文章 先了解下基础的网络知识。 目前存在的两种网络分层模型：OSI模型和TCP/IP模型。OSI模型一共分为七层，TCP/IP模型和OSI模型类似，但是只分为四层。 OSI模型 应用层(Application) 表示层(Presentation) 会话层(Session) 传输层(Transport) 网络层(Network) 数据链路层(Data Link) 物理层(Physical) TCP/IP模型TCP/IP模型分为四层：应用层（Application）、传输层（Host-to-Host Transport）、互联网层(Internet)、网络接口层(Network Interface)。 在TCP/IP模型中并不包含物理层。另外，两个重要的协议ARP（Address Resolution Protocol，地址解析协议）和RARP（Reverse Address Resolution Protocol，反向地址转换协议），在OSI模型中一般被认为是在位于第二层数据链路层和第三层网络层之间，而在TCP/IP模型中则位于网络接口层。 应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等 传输层：TCP，UDP 网络层：IP，ICMP，OSPF，EIGRP，IGMP 数据链路层：SLIP，CSLIP，PPP，MTU 每一抽象层建立在低一层提供的服务上，并且为高一层提供服务 TCP 三次握手与四次挥手TCP (Transmission Control Protocol) 传输控制协议 TCP 提供一种面向连接的、可靠的字节流服务 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP TCP 使用校验,确认和重传机制来保证可靠传输 TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复 TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制 注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。 三次握手所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。 三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。 第一次握手(SYN=1, seq=x): 客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。 发送完毕后，客户端进入 SYN_SEND 状态。 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1): 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。 第三次握手(ACK=1，ACKnum=y+1) 客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1 发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。 四次挥手客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。 第一次挥手(FIN=1，seq=x) 假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。 发送完毕后，客户端进入 FIN_WAIT_1 状态。 第二次挥手(ACK=1，ACKnum=x+1) 服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。 发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。 第三次挥手(FIN=1，seq=y) 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。 发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。 第四次挥手(ACK=1，ACKnum=y+1) 客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。 服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。 客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。 UDP （User Datagram Protoco）用户数据报协议UDP 是一个简单的传输层协议。和 TCP 相比，UDP 有下面几个显著特性： UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次 UDP 数据报是有长度的。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界。 UDP 是无连接的。UDP 客户和服务器之前不必存在长期的关系。UDP 发送数据报之前也不需要经过握手创建连接的过程。 UDP 支持多播和广播。 SocketSocket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 socket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种”打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。 Http 协议 HTTP 协议构建于 TCP/IP 协议之上，是一个应用层协议，默认端口号是 80 HTTP 是无连接无状态的]]></content>
      <tags>
        <tag>网络</tag>
        <tag>tcp</tag>
        <tag>ip</tag>
        <tag>http</tag>
        <tag>socket</tag>
        <tag>三次握手</tag>
        <tag>四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView 优化及相关问题总结]]></title>
    <url>%2FListView-%E4%BC%98%E5%8C%96%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[ListView 优化最近在做项目过程中频繁使用列表，今天抽空总结下过程中遇到的问题，下面会有具体对应的解决办法； 1.listView 外套一层ScrollView 的问题，就是listView 只显示一行或者两行， 我发现这个问题在 RecycleView 上也存在， 在RecycleView外套一层 ScrollView也会出现只显示一行的问题，滑动只能在 一行的高度内滑动。这问题下面有具体解决方案，说下我是怎么解决的吧，因为我要实现的是9宫格的图片展示，本来是用的RecycleView 来实现的，出现了这个问题，我就尝试把recyclerView 换成了GridView 了，因为GridView 本身就支持多行展示，发现就没有这个问题了，套了ScrollView 也正常展示； 2.也是listView 在嵌套ScrollView 中的问题，在某款三星手机上，这个手机的虚拟按键，可以锁定和解锁定， 发现在切换锁定和解锁定中，会导致原来的多行的图片变成单行， 在别的手机上就没有这个问题， 这个奇怪的现象，最终还是以GridView 替换掉listView 解决的。 3.listView 添加 headerView的问题， 需要注意的是 添加进去的 HeaderView 就占据了第0位，所以在使用的 onItemClick 的时候，需要-1， addfooterView的时候可以用 view.getFooterViewsCount() 是否等于0来判断，避免多次添加。 4.由于listView 会复用viewHolder ，所以我们在getView 中 显示隐藏的设置一定要配套使用，if里有显示，在else 中就要 隐藏。 优化步骤：使用 RecycleView 代替listview 1.重用ConvertView; 2.使用View Holder模式； 3.使用异步线程加载图片（一般都是直接使用图片库加载，如Glide, Picasso）；建议: 1.在adapter的getView方法中尽可能的减少逻辑判断，特别是耗时的判断； 2.避免GC 3.在快速滑动时不要加载图片； 4.将ListView的scrollingCache和animateCache这两个属性设置为false（默认是true）; 5.尽可能减少List Item的Layout层次（如可以使用RelativeLayout替换LinearLayout，或使用自定的View代替组合嵌套使用的Layout） ListView 嵌套 ScrollViewListview不能显示正常的条目，只显示一条或二条 这是因为：由于listView在scrollView中无法正确计算它的大小, 故只显示一行。 解决方案:1. 方法一：重写ListView, 覆盖onMeasure()方法1234567891011121314151617181920212223WrapperListView.java:public class WrapperListView extends ListView &#123; public WrapperListView(Context context) &#123; super(context); &#125; public WrapperListView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public WrapperListView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; public WrapperListView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context, attrs, defStyleAttr, defStyleRes); &#125; /** * 重写该方法，达到使ListView适应ScrollView的效果 */ protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2, MeasureSpec.AT_MOST); super.onMeasure(widthMeasureSpec, expandSpec); &#125;&#125; 2.方法二：动态设置listview的高度，不需要重写ListView只需要在setAdapter之后调用如下方法即可： 123456789101112131415161718192021public void setListViewHeightBasedOnChildren(ListView listView) &#123; // 获取ListView对应的Adapter ListAdapter listAdapter = listView.getAdapter(); if (listAdapter == null) &#123; return; &#125; int totalHeight = 0; for (int i = 0, len = listAdapter.getCount(); i &lt; len; i++) &#123; // listAdapter.getCount()返回数据项的数目 View listItem = listAdapter.getView(i, null, listView); // 计算子项View 的宽高 listItem.measure(0, 0); // 统计所有子项的总高度 totalHeight += listItem.getMeasuredHeight(); &#125; ViewGroup.LayoutParams params = listView.getLayoutParams(); params.height = totalHeight + (listView.getDividerHeight() * (listAdapter.getCount() - 1)); // listView.getDividerHeight()获取子项间分隔符占用的高度 // params.height最后得到整个ListView完整显示需要的高度 listView.setLayoutParams(params); &#125; 这时最好给ListView之外嵌套一层LinearLayout，不然有时候这种方法会失效 3.方法三：在xml文件中，直接将Listview的高度写死可以确定的是：这种方式可以改变ListView的高度，但是，还有一个严重的问题就是listview的数据是可变动的，除非你能正确的写出listview的高度，否则这种方式就是个鸡肋。 4. addHeadView()如果只有数据 layout 完全没有必要嵌套 ScrollView 的.之说以需要嵌套,很多是在listView 头部或者底部多了一部分Layout ,这个时候可以尝试 listView 的 addHeadView() 尝试解决 在一次显示ListView的界面时，getView会被执行几次？比如有5组数据要填充到listView。listView会先调用onMeasure，此时会调用5次getView。然后才调用onLayout，此时又会调用5次getView，这样就重复了。所以导致多次调用getView方法 的确调用了三遍 解决办法: ListView 的高度 从 wrap_content 改成 match_patent 或者一个固定值,就能减少getview 调用次数 或者重写 listView 的onMasure onLayout 方法 赋值 一个变量 检测 是测量还是layout 测量时不加载自己写的那段逻辑 listview失去焦点怎么处理？在listview子布局里面写，可以解决焦点失去的问题android:descendantFocusability=”blocksDescendants” ListView 优化 1.首先，虽然大家都知道，还是提一下，利用好 convertView 来重用 View，切忌每次 getView() 都新建。ListView 的核心原理就是重用 View。ListView 中有一个回收器，Item 滑出界面的时候 View 会回收到这里，需要显示新的 Item 的时候，就尽量重用回收器里面的 View。 2.利用好 View Type，例如你的 ListView 中有几个类型的 Item，需要给每个类型创建不同的 View，这样有利于 ListView 的回收，当然类型不能太多 3.尽量让 ItemView 的 Layout 层次结构简单，这是所有 Layout 都必须遵循的 4.善用自定义 View，自定义 View 可以有效的减小 Layout 的层级，而且对绘制过程可以很好的控制； 5.尽量能保证 Adapter 的 hasStableIds() 返回 true，这样在 notifyDataSetChanged() 的时候，如果 id 不变，ListView 将不会重新绘制这个 View，达到优化的目的； 6.每个 Item 不能太高，特别是不要超过屏幕的高度，可以参考 Facebook 的优化方法，把特别复杂的 Item 分解成若干小的 Item， 7.为了保证 ListView 滑动的流畅性，getView() 中要做尽量少的事情，不要有耗时的操作。特别是滑动的时候不要加载图片，停下来再加载，这个库可以帮助你 Glide：https://github.com/bumptech/glide 8.使用 RecycleView 代替。 ListView 每次更新数据都要 notifyDataSetChanged()，有些太暴力了。RecycleView 在性能和可定制性上都有很大的改善，推荐使用。]]></content>
      <tags>
        <tag>Android listView</tag>
        <tag>ListView优化</tag>
        <tag>列表优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站优化]]></title>
    <url>%2F%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[网站在今年2月份就创建了，但是一直没有怎么优化。最近几天，简单美化了一下现在就把相关的优化网站列一下，希望对读者有点帮助。 Github Pages + Hexo 博客搭建，Next主题个性化修改 有很多链接，包括从创建到优化，还有视频教程。 Hexo博客主题安装及Next主题个性化修改 不得不说，这个对我帮助很大。 hexo - Next 主题添加评论功能 这个是给我们的网站加评论的， 我选择 Valine 评论系统 ，我希望可以匿名评论。 后续还有 seo 优化还没有做，这个会继续更新的。]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>页面优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中公共代码仓库与私服的使用]]></title>
    <url>%2FAndroid%E4%B8%AD%E5%85%AC%E5%85%B1%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93%E4%B8%8E%E7%A7%81%E6%9C%8D%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[上篇文章 从ARM暂停与华为合作谈起 Android中SO兼容的那些事 中提到了我们是用自己私服上的weex sdk 出的问题继而解决的问题,今天就来介绍下我们的私服, 并手把手教会你怎么创建并使用私服. 背景随着公司业务发展，项目越来越大，项目有好几个，项目虽然具体业务不同，但是其中也有很多相同的功能， 比如都有 weex 需求，网络请求、 图片处理、视频处理等等共同的需求，如果每个项目都重新写一遍，实现一遍，势必影响进度，重复造轮子的问题，项目进展缓慢，所以 就需要一种方式来避免这种重复劳动，彻底解决这种问题。 解决办法 : 使用组件化的思想， 把公共的组件抽离出来，和主项目的关系是依赖主项目的关系。module 是以 library的形式存在于整个project 中，依赖于主工程。在需要使用的时候，引入即可。类似我们使用 recyclerview butterknife 之类的这些的功能， 这些内容有的是 Android官方提供的支持，有的是国内外优秀开发者开源出来的控件，我们可以很方便的集成到项目中。如下图： 知名仓库介绍目前有 jcenter（） ，mavenCentral（）， google（） 等等仓库中心，这些仓库是用来保存代码的，组织或者个人开发者 开源出很多优秀的代码，工具，控件，上传到这些仓库中，我们可以通过 在 gradle 中配置相应的仓库地址 ，就可以方便使用相应的代码， 而内部使用的组件，不适合开源的可以自己搭建 私有仓库，内网使用，还有一些需要借助代理访问，国内访问起来特别慢或者无法访问的内容，也可以上传到我们的私服上，能够很好地提高效率，减少同步等待时间类似下图 我们在其中一个项目中使用的 仓库地址： 我们通过在 gradle 中配置相应的依赖，项目在 build 完成后就会将相应的 依赖工程代码 下载到 项目中， 可以在project 模式下 查看 External Libraries 看到实际下载下来的代码。 下面分别介绍下 这几个仓库，和私有仓库的搭建 jcenter网页地址 http://jcenter.bintray.com/ mavenCentral网页地址http://central.maven.org/maven2/ google网页地址 https://dl.google.com/dl/android/maven2/ 其他仓库以阿里云为例网页地址 http://maven.aliyun.com/nexus/content/repositories/jcenter/ 上图中已经展示了 在项目中的配置这些仓库的方式。 这些仓库又有什么区别呢？maven中央仓库（http://repo1.maven.org/maven2/）是由Sonatype公司提供的服务，它是Apache Maven、SBT和其他构建系统的默认仓库，并能很容易被Apache Ant/Ivy、Gradle和其他工具所使用。开源组织例如Apache软件基金会、Eclipse基金会、JBoss和很多个人开源项目都将构件发布到中央仓库。 maven中央仓库已经将内容浏览功能禁掉了。 jcenter仓库（https://jcenter.bintray.com ）是由JFrog公司提供的Bintray中的Java仓库。它是当前世界上最大的Java和Android开源软件构件仓库。 所有内容都通过内容分发网络（CDN）使用加密https连接获取。JCenter是Goovy Grape内的默认仓库，Gradle内建支持（jcenter()仓库），非常易于在（可能除了Maven之外的）其他构建工具内进行配置。 JCenter相比mavenCenter构件更多，性能也更好。但还是有些构件仅存在mavenCenter中。 google（）存储库是Google maven资源库的快捷方式。 它是在Gradle 4.x +中引入的。 使用的实际存储库URL是“https://dl.google.com/dl/android/maven2/”， 也可以使用 maven { url ‘https://maven.google.com&#39; }但是 google（），则需要Gradle 4.x +，Android Studio 3.x +和Android 3.x +的Gradle插件。 maven (阿里云) maven.aliyun.com代理了很多公共的maven仓库。使用maven.aliyun.com中的仓库地址作为下载源，速度更快更稳定。https://maven.aliyun.com/repository/public 是 central仓和jcenter仓的聚合仓 经过测试发现，可以代替 central 和 jcenter ，把阿里云的这个放到第一位会加快同步速度。 阿里云除了代理了 mavenCentral, jcenter还有 上面的 google() 基本上主流的 仓库都有, 在国内这个网络环境下, 使用阿里云的代理仓库是一个挺好的选择. 什么是Maven？Maven 是一个项目管理和自动构建工具。是一个软件（特别是Java软件）项目管理以及自动构建工具，由Apache软件基金会所提供。是基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。Maven也可以被利用与构建和管理各种项目，例如：C#、Ruby、Scala和其他语言编写的项目。Maven项目使用项目对象模型（Project Object Modle，POM）来配置项目，对象模型存储在名为pom.xm的文件中。 什么是Gradle？Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建工具，是一款通用灵活的构建工具，支持maven， Ivy仓库，支持传递性依赖管理，而不需要远程仓库或者是pom.xml和ivy.xml配置文件，基于Groovy（DSL语言，所谓的DSL是指这个语言应用在特定的领域，而类似Java这样是DCL语言，可以运用在普通的各个领域），而不是传统的xml语言，build脚本使用Groovy编写。当前支持的语言仅限于Java、Groovy、Scala、Kotlin。计划未来支持更多的语言。 Gradle改良了过去Maven、Ant带给开发者的问题，也已经成为Android Studio内置封装部署工具 Android支持的Maven仓库： 1.mavenCentral 是最早的 maven 中央仓库 2.jcenter 是 Android Studio 0.8 版本起的默认 maven 中央仓库 3.本机的仓库 4.部署在内网服务器的私有仓库 上面也说了，我们可以把自己写的优秀代码共享到这些代码仓库中供全世界 开发者使用，但是由于公司的项目很多不能公开，只可在公司范围使用，又需要在不同项目中可以方便接入，在后续功能修改时 又能通过版本控制 使用修改前后的功能均可正常使用， 这个时候可以 搭建私有 maven 仓库，部署我们的公共组件代码，就可以方便使用了。 使用Nexus搭建 maven 私服下面演示在window上的安装过程 1.下载Nexus下载地址：http://www.sonatype.com/download-oss-sonatype 2.解压zip文件，配置nexus下bin目录全局变量 然后打开我的电脑-&gt;属性-&gt;高级系统设置-&gt;高级-&gt;环境变量 在path 中配置 上面的bin 文件夹的路径进去 F:\Downloads\nexus-3.16.1-02-win64\nexus-3.16.1-02\bin 3.安装nexus服务，以管理员身份运行 cmd 进入 上面bin的文件夹下， 运行nexus.exe/install Nexus Service命令查看服务里就能看到 4.启动服务,启动这个服务，稍等一会时间，在浏览器中访问 http://localhost:8081/。就能够看到这个页面 默认的用户名和密码登录（admin/admin123） 目前为止 服务搭建成功。 仓库的详细配置过程，请移步到官方网站http://books.sonatype.com/nexus-book/reference3/admin.html#admin-repositories 下面来看怎么使用的问题； 上传 aar 到我们搭建的私服上 步骤1. Nexus创建自己的仓库访问：http://localhost:8081/nexus，先创建一个你要上传的仓库信息： 点击create repository name那输入你想创建的名称，如 younger然后点创建，就可以看到了自己的仓库 http://10.1.1.147:8081/repository/younger/ （此ip为我自己电脑局域网ip） 2. Android Studio 配置新建一个module，这个module就是你要编译的aarmodule下gradle配置如下，添加代码：apply plugin:’maven’ 和 1234567891011121314151617uploadArchives &#123; configuration = configurations.archives repositories &#123; mavenDeployer &#123; repository(url: 'http://10.1.1.147:8081/repository/younger/') &#123; authentication(userName: 'admin', password: 'admin123') &#125; pom.project &#123; version '0.0.1' artifactId 'testmaven' groupId 'demo.younger.com' packaging 'aar' description 'update version 0.0.1' &#125; &#125; &#125;&#125; groupId，version要注意填好。然后，在Gradle projects列表中可以看到upload的Task点击后即可编译上传，success后就可以了。 可以看到编译成功 ，在Nexus后台可以看到： 3. Android Studio 中引用//添加仓库在根gradle 中添加 1234567891011allprojects &#123; repositories &#123; google() jcenter()//新增 maven &#123; url 'http://10.1.1.147:8081/repository/younger/' &#125; &#125;&#125; 在项目的gradle 中使用1implementation 'demo.younger.com:testmaven:0.0.1' 就可以正常引用了， 可以看到上面的顺序是 groupId ：artifactId： version 也可以在 External Libraries 查看到 项目中也可以引用啦 目前项目中weex就是采用这种方式， 搭建一个nexus 私服，把weex 官方的sdk 下载下来，我们根据项目需要，自行实现很多不同的功能，而这些功能在不同的项目都可以用到，就统一放到私服上，在我们具体的项目中，只需要简单设置，就可以非常方便的使用这些功能，如果新增了什么功能，可以直接把代码上传到公共组件中，升级版本， 项目中用的时候只需要改成相应的版本号就可以方便使用到最新的功能。 总结可以发现，创建私服，上传aar文件， 引用都非常简单， 具体有没有必要使用还是需要根据自身实际情况来看，那些公共仓库上的内容可以优先使用阿里云的代理仓库，这样会加快同步速度，自己内部使用或者比较特殊的内容就可以放到私服上了，同样是特别方便。]]></content>
      <tags>
        <tag>Android私服</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从ARM暂停与华为合作谈起 Android中SO兼容的那些事]]></title>
    <url>%2FAndroid%E4%B8%ADSO%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[因为包含来自美国的技术，ARM（英国）已经要求员工“停止所有与华为及其子公司正在生效的合约、支持及未决约定” 从最近的新闻来看，美国的贸易禁令使得华为公司腹背受敌，ARM彻底暂停与华为合作已成定局，最新款的芯片技术肯定是用不上了，不过华为已经获得了ARMv8的永久授权。但是ARM是什么样的存在？ 为什么对华为有这么大的影响力呢，事实上 ARM处理器 已经一统移动端了。今天就来谈谈 ARM 与 Android SO 的那些事。 背景:公司某项目新上功能部分页面使用 weex 来做的，测试过程中发现 weex 页面在某些手机上出现异常，经过排查定位到是 SO 库的问题，下面是这个问题的解决过程的一个记录，希望能对遇到类似问题的同学提供一些帮助。 什么问题?公司某项目 V1.2.0版本最初上线时，使用的 weex 是官方的 SDK 的接入方式， 接下来 App版本需要把官方的 SDK 替换成我们自己私服上的 SDK（因为私服上有我们针对自己项目需要，自定义了许多控件和公共组件） ，替换后，出现 weex 页面加载异常的问题（白屏） 报错信息如下： 我们注意到，上面有一行错误是 invokeInitFramework java.lang.UnsatisfiedLinkError: 见过该错误的开发者都知道，这个是 JNI 相关的错误信息，根据错误信息能看到是 weex 相关的 JNI 调用出了问题，由JNI 又想到了 SO 库文件， 那就引出今天的话题。 什么是 SO 文件及SO 应用？SO（shared object，共享库）是机器可以直接运行的二进制代码 SO 机制让开发者最大化利用已有的 C 和 C++ 代码，达到复用的效果，利用软件世界积累了几十年的优秀代码； SO 是二进制，没有解释编译的开销，用SO实现的功能比纯java实现的功能要快； SO 内存分配不受 Dalivik/ART 的单个应用限制，减少 OOM； 相对于java代码，二进制代码的反编译难度更大，一些核心代码可以考虑放在 SO 中。 在Android 中 提到 SO 就不能不提 ABI ABI应用程序二进制接口（Application Binary Interface） 定义了其所对应的CPU架构能够执行的二进制文件（特别是.so文件）的格式规范。在 Android 系统上，不同 Android 手机使用不同的 CPU，因此支持不同的指令集。CPU 与指令集的每种组合都有其相应的应用二进制界面（或 ABI）。 ABI 可以非常精确地定义应用的机器代码在运行时如何与系统交互。 您必须为应用要使用的每个 CPU 架构指定 ABI：armeabi，armeabi-v7a，arm64-v8a，x86，x86_64，mips，mips64； 目前 Android 共支持七种不同类型的 CPU 架构，分别是：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起) SO（CPU）的兼容每一个 CPU 架构对应一个 ABI，一个 CPU 属于某一种架构，多核 CPU 属于相同架构才能一起工作，很多设备仅支持一种 CPU 架构。 如果你要完美兼容所有类型的机型，理论上是要在的 libs 目录下放置各个架构平台的 SO 文件。 但项目体积也会变得非常庞大。是否一定需要带入这么多SO文件去兼容呢？答案是否定的。 根据目前Android共支持七种不同类型的CPU架构，其兼容特点可总结如下： armeabi设备只兼容armeabi； armeabi-v7a设备兼容armeabi-v7a、armeabi； arm64-v8a设备兼容arm64-v8a、armeabi-v7a、armeabi； X86设备兼容X86、armeabi； X86_64设备兼容X86_64、X86、armeabi； mips64设备兼容mips64、mips； mips只兼容mips； armeabi 的 SO 文件基本上可以说是兼容目前市面上的大部分手机，它能运行在除了mips和mips64的设备上，但在非 armeabi 设备上运行性能会有所损耗； 64位的CPU架构总能向下兼容其对应的32位指令集，如：x86_64兼容X86，arm64-v8a兼容armeabi-v7a，mips64兼容mips； 总结成一句话就是， 新的CPU 架构总能向下兼容； 所以知道这些信息后，查看公司其他项目怎么用的, 发现其他项目, 在 build.gradle 中关于 ndk.abiFilters 都是这样写的： 而这个项目的写法是这样的： 区别就是这个 ndk.abiFilters ， 既然这样写，必定有它的原因， 那就继续找，为什么要这么写，咨询相关的同事，了解到相关路径下的文件是 视频聊天、语音相关的 SO 库。 那能不能改成只支持 armeabi 或者 他们其中的部分呢。那就模拟这些情况，然后分别打出了这么多包（包的命名有点随意，这不是重点），分别在不同的手机上验证是否能正常加载 weex 。 经测试发现 armeabi 的和 armeabi +x86 的都可以正常加载 weex 页面，感觉问题这么简单就解决了，但是！！！ 想到去掉这么多东西 会不会影响其他正常功能呢， 那就验证下吧，试了下视频相关功能，果不其然的 app 崩溃了。 说明上面的方向肯定是有问题，使用工具 Native libs Monitor 查看下Apk 中具体的SO 文件 首先查看下那些我们常用的App 是怎么做的，微信、QQ、支付宝等等 其他公司如何适配的 微信（只适配armeabi，有少量 v7a）； qq（只适配armeabi，文件夹下有少量x86）； 百度地图（只适配armeabi）； 大众点评（只适配armeabi）； google 家 （基本都是 arm64）； 支付宝 （基本都是 armeabi 的，2个x86的）； 而且 公司别的项目App 中 用到的 face++ 的人脸识别，身份证识别 也是只提供了armeabi 的SO 文件 下图是微信的Apk 解压出的情况， 微信的lib下虽然只有armeabi-v7a一个目录，但目录内的文件仍放着v7a和 armeabi架构的SO文件，用于处理兼容带来的某些性能运算问题。 看完大公司的适配情况，然后看下我们自己 公司这几个项目，看看到底有什么区别， 还有上面打出的不同的包，相应的 SO 引入情况。 经过对比发现， 指定不同的 abi 会 在apk 中 打入相应 的文件(前提是 你有这些文件)，这就是一个过滤器，只在包中引入指定的cpu 架构的 SO 文件。 既然重点是 weex 加载的出了问题，然后就重点查看 weex 相关的 SO 引入情况， 既然官方的可以正常使用， 我们私服上却出了问题，然后对比使用官方的 sdk 集成方式,和我们私服上的集成方式的 SO 库有什么不同； 如图是集成weex 官方sdk 的 APK 而集成私服上的 sdk 后，只在 armv5中有 libweexjsc.so 而 armv7 中是没有这个问题的。 区别找到了，那就去私服的项目中找原因 并没有 armeabi-v7a 的文件，相应的 lib下也没有相应的文件夹和文件，按照一样的写法，在这加入 armeabi-v7a 相应的路径，相应的 lib 下，也新建了相应的文件夹，放入相应的文件。重新编译 再次尝试, 查看 lib 在 arm v7 和 v8a 的手机上,查看 lib 情况,发现, 在都能看到相应的 SO 文件了, 多部手机尝试， 视频聊天、语音、 weex 都正常、至此 问题得到解决。 在排查问题的过程中发现，其实这个项目 本来的 build.gradle 文件中的 arm64-v8a 写错了，以前写成了 armeabi-v8a 其实这样是无法使用到 arm64-v8a下的 so 的。 但是会向下兼容, 使用了 armeabi-v7a 中的文件，也没有报错，其实也是因祸得福，如果写正确的话，weex 在 arm64-v8a 也会加载失败，因为 官方也没有提供这样的一个文件夹和文件。 但是我们要怎么配置呢？ 从目前移动端CPU市场的份额数据看，ARM架构几乎垄断，所以，除非你的用户很特殊，否则几乎可以不考虑单独编译带入X86、X86_64、mips、mips64架构SO文件。除去这四个架构之后，还要带入armeabi、armeabi-v7a、arm64-v8a 这三个不同类型，这对于一个拥有大量SO文件的应用来说，安装包的体积将会增大不少。 针对不同平台，如何去适配，如何抉择目前主流的Android设备主要是 armeabi-v7a ARMv8 架构的，程序在运行的时候去加载不同平台对应的so，这是较为完美的一种解决方案，但是有时候为了减少包体积的大小， 不会同时设置 armeabi， armeabi-v7a 和 x86。根据不同的情况，可以进行不同的适配， 1.只适配 armeabi-v7a，因为目前主流机型是 ARMv7，并且 ARMv8 设备也向下兼容了armeabi-v7a， Facebook、WhatsApp、王者荣耀等就是只适配了armeabi-v7a。（Google play store下载 Native libs Monitor 进行查看）。 2.只适配 armeabi，因为 ARMv7 、ARMv8 还是 x86 都兼容 armeabi，但是性能都会有些损耗，例如ARMv7 支持硬件浮点运算等没法体现，x86 支持 armeabi 同样具有相应的损耗。 3.同时适配 armeabi-v7a 和 armeabi，既能够支持所有 ARM 架构，同时又能具有 ARMv7 支持硬件浮点运算等特性，例如Line等应用。 4.同时适配 x86 和 armeabi，既能支持所有 ARM 架构，又能支持x86架构，唯一的缺点就是没有了ARMv7 支持硬件浮点运算等一系列特性，例如QQ。 5.同时适配 armeabi， armeabi-v7a 和 x86，在性能方面来说是较为完美的方案，只是APK的大小也会随之变大。 6.还有其他的一些方案，例如微信只适配了armeabi，但是对于某些需要利用 ARMv7 支持硬件浮点运算等一系列特性的操作，在armeabi目录下存在v7对应的so文件，通过代码判断加载不同的so文件。即达到了减少APK大小的目的，又能达到适配ARMv7等架构以便使用其架构的一些新特性的目的。 就目前市场份额而言，绝大部分的设备都已经是armeabi-v7a、arm64-v8a，可以考虑只保留armeabi-v7a架构的SO文件，这样能获得更好的性能效果。所以我们的 这个项目选择采用第3种方案； 现在把这个项目中的 ndk.abiFilters 配置成上图所示，几乎覆盖所有机型，weex 能够正常加载，暂时没有发现影响其他功能，这个问题也算是得到解决。在不影响太多性能的情况下，也可以明显减少包的体积。 总结下常见的 引入.so文件的错误1.使用android高版本平台版本编译的.so文件运行在android低版本的设备上使用NDK时，你可能会倾向于使用最新的编译平台，但事实上这是错误的，因为NDK平台不是向下兼容的，而是向上兼容的。推荐使用app的minSdkVersion对应的编译平台。 这也意味着当你引入一个预编译好的.so文件时，你需要检查它编译时所用的平台版本。 2.没有为每个支持的CPU架构提供对应的.so文件arm64-v8a是可以向下兼容的，但前提是你的项目里面没有arm64-v8a的文件夹，如果你有两个文件夹armeabi和arm64-v8a，两个文件夹，armeabi里面有a.so 和 b.so,arm64-v8a里面只有a.so， 那么arm64-v8a的手机在用到b的时候发现有arm64-v8a的文件夹，发现里面没有b.so，就报错了， 所以这个时候删掉arm64-v8a文件夹，这个时候手机发现没有适配arm64-v8a，就会直接去找armeabi的so库，或者把 arm64-v8a文件夹 的 b.so补齐。 参考文章：https://zhuanlan.zhihu.com/p/21302804 https://www.zhihu.com/question/36893314/answer/78467097 https://blog.csdn.net/zophar_development/article/details/84329054 https://www.cnblogs.com/janehlp/p/7473240.html https://www.jianshu.com/p/cb05698a1968 https://www.jianshu.com/p/cb15ba69fa89 等]]></content>
      <tags>
        <tag>Android SO兼容</tag>
        <tag>SO</tag>
        <tag>华为</tag>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开站顺利]]></title>
    <url>%2F%E5%BC%80%E7%AB%99%E9%A1%BA%E5%88%A9.html</url>
    <content type="text"><![CDATA[这是Younger 的第一篇内容终于我也有自己的个人网站了 昨天是周日,下午开始弄这个,申请域名, 搭建网站,整个过程真的好简单,以前一直以为很难的,就一直没有动手的去弄; 目前来看, 困难都是自己想象出来的, 真正动手去做,就会发现,也没有那么难,真正需要做的就是行动, 勇敢踏出第一步 购买域名域名是在 namesilo 买的, 用了优惠码后一年也就是不到50元,支持支付宝支付,方便至极 ,如果有需要可以寻找网上的优惠码, 可以节省1美元, 我这个域名买下来一年5.99美元,也就是不到45块钱,可谓是相当的划算了. 关于域名商的选择我也是查了下资料, 之所以没有选择国内的服务商, 主要是众所周知的原因, 国内的需要备案, 且你的域名随时可能被关掉等不安全因素, 还是在国际知名的大的域名商买比较靠谱, namesilo 这个打的广告比较少, 说是让利给消费者, 的确是很便宜, 我是对比了多家, 发现这家便宜的, 还有 namecheap 也比较便宜. 这个还是见仁见智了, 想买哪个都行, 续费便宜, 服务好就行. 主机使用的是 github.io + hexo 搭建的,过程非常的简单, 感谢各位大佬的教程 hexo官网的文档 也很详细,还有视频教程,另外还有好多主题供选择; 傻瓜式安装.每一步都有详细的教程, 然后就成了我现在弄的这个样子, 后续我肯定还会继续更新的. 今天简单弄了一下,记录一下, 虽然用的也都是别人的轮子,但还是很开心呀!]]></content>
      <tags>
        <tag>网站搭建</tag>
        <tag>域名购买</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>namesilo</tag>
      </tags>
  </entry>
</search>
